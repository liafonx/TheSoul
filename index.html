<!DOCTYPE html>
<html>
  <script>
    var Immolate = {
      onRuntimeInitialized: function () {
        if (window.instantAnalysis) {
          performAnalysis();
        }
      },
    };

    // Helper function for vectors
    function asVector(arr) {
      var vectorInt = new Module.VectorStr();
      for (var i = 0; i < arr.length; i++) {
        vectorInt.push_back(arr[i]);
      }
      return vectorInt;
    }
  </script>
  <script src="immolate.js"></script>
  <script src="balatro_lists.js"></script>
  <script src="UI.js" defer></script>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Soul</title>
    <link rel="stylesheet" href="base.css" />
    <link rel="stylesheet" href="ui.css" />
    <link rel="icon" type="image/png" href="images/icon.ico" />
  </head>
  <body>
    <h1 class="site-title">
      <img
        src="images/icon.ico"
        alt="The Soul icon"
        class="site-title-icon"
        width="48"
        height="48"
      />
      <span>The Soul</span>
    </h1>
    <div class="container">
      <div class="input-section">
        <h2>Settings</h2>

        <div class="settings-grid">
          <div class="settings-field">
            <label for="seed">Seed:</label>
            <input
              type="text"
              id="seed"
              maxlength="8"
              pattern="[A-Z1-9]{1,8}"
              class="settings-core-input"
              required
            />
          </div>

          <div class="settings-field">
            <label for="ante">Max Ante:</label>
            <input
              type="number"
              id="ante"
              min="1"
              max="999"
              class="settings-core-input"
              value="39"
              required
            />
          </div>

          <div class="settings-field">
            <label for="cardsPerAnte">Cards per Ante:</label>
            <input
              type="number"
              id="cardsPerAnte"
              min="0"
              max="999"
              value="300"
              class="settings-core-input"
              required
            />
          </div>

          <div class="settings-field">
            <label for="deck">Deck:</label>
            <select id="deck" required>
              <option value="Red Deck">Red Deck</option>
              <option value="Blue Deck">Blue Deck</option>
              <option value="Yellow Deck">Yellow Deck</option>
              <option value="Green Deck">Green Deck</option>
              <option value="Black Deck">Black Deck</option>
              <option value="Magic Deck">Magic Deck</option>
              <option value="Nebula Deck">Nebula Deck</option>
              <option value="Ghost Deck">Ghost Deck</option>
              <option value="Abandoned Deck">Abandoned Deck</option>
              <option value="Checkered Deck">Checkered Deck</option>
              <option value="Zodiac Deck">Zodiac Deck</option>
              <option value="Painted Deck">Painted Deck</option>
              <option value="Anaglyph Deck">Anaglyph Deck</option>
              <option value="Plasma Deck" selected>Plasma Deck</option>
              <option value="Erratic Deck">Erratic Deck</option>
              <!-- Add deck options here -->
            </select>
          </div>

          <div class="settings-field">
            <label for="stake">Stake:</label>
            <select id="stake" required>
              <option value="White Stake">White Stake</option>
              <option value="Red Stake">Red Stake</option>
              <option value="Green Stake">Green Stake</option>
              <option value="Black Stake">Black Stake</option>
              <option value="Blue Stake">Blue Stake</option>
              <option value="Purple Stake">Purple Stake</option>
              <option value="Orange Stake">Orange Stake</option>
              <option value="Gold Stake">Gold Stake</option>
              <!-- Add stake options here -->
            </select>
          </div>

          <div class="settings-field">
            <label for="version">Version:</label>
            <select id="version" required>
              <option value="10115">1.0.1o-full</option>
              <option value="10014">1.0.0n</option>
              <option value="10106">1.0.1f</option>
              <option value="10103">1.0.1c</option>
              <!-- Add version options here -->
            </select>
          </div>
        </div>

        <div class="checkbox-row">
          <input type="checkbox" id="omitBeforeAnte9" checked />
          <label for="omitBeforeAnte9">Omit results before Ante 9</label>
        </div>

        <div class="settings-actions">
          <button id="analyzeButton">Analyze</button>
          <button id="openCheckboxesBtn">Modify Unlocks</button>
          <button id="copyButton">Copy Link</button>
          <button id="downloadButton">Download output</button>
          <button id="exportButton">Summarize</button>
          <div class="checkbox-row export-toggle">
            <input type="checkbox" id="withEnglishToggle" />
            <label for="withEnglishToggle">with English</label>
          </div>
        </div>

        <div id="checkboxesOverlay">
          <div id="checkboxesPopup">
            <h2>Unlocked Items</h2>
            <div id="checkboxesContainer" class="clearfix"></div>
            <button id="submitBtn">Submit</button>
            <button id="unlockBtn">Unlock All</button>
            <button id="lockBtn">Lock All</button>
          </div>
        </div>
      </div>
    </div>
    <div id="summaryFloatingWindow">
      <div id="summaryFloatingContent" aria-live="polite"></div>
    </div>
    <div id="summaryFilterWindow">
      <div id="summaryFilterContent"></div>
    </div>
    <button id="summaryFloatingToggle" type="button">Summary</button>
    <button id="summaryFilterToggle" type="button">Filter</button>
  </body>
  <script>
    // Unlocks stuff
    // Option values
    const options = [
      "Negative Tag",
      "Foil Tag",
      "Holographic Tag",
      "Polychrome Tag",
      "Rare Tag",
      "Golden Ticket",
      "Mr. Bones",
      "Acrobat",
      "Sock and Buskin",
      "Swashbuckler",
      "Troubadour",
      "Certificate",
      "Smeared Joker",
      "Throwback",
      "Hanging Chad",
      "Rough Gem",
      "Bloodstone",
      "Arrowhead",
      "Onyx Agate",
      "Glass Joker",
      "Showman",
      "Flower Pot",
      "Blueprint",
      "Wee Joker",
      "Merry Andy",
      "Oops! All 6s",
      "The Idol",
      "Seeing Double",
      "Matador",
      "Hit the Road",
      "The Duo",
      "The Trio",
      "The Family",
      "The Order",
      "The Tribe",
      "Stuntman",
      "Invisible Joker",
      "Brainstorm",
      "Satellite",
      "Shoot the Moon",
      "Driver's License",
      "Cartomancer",
      "Astronomer",
      "Burnt Joker",
      "Bootstraps",
      "Overstock Plus",
      "Liquidation",
      "Glow Up",
      "Reroll Glut",
      "Omen Globe",
      "Observatory",
      "Nacho Tong",
      "Recyclomancy",
      "Tarot Tycoon",
      "Planet Tycoon",
      "Money Tree",
      "Antimatter",
      "Illusion",
      "Petroglyph",
      "Retcon",
      "Palette",
    ];
    selectedOptions = Array(61).fill(true);

    // Get references to elements
    const openCheckboxesBtn = document.getElementById("openCheckboxesBtn");
    const checkboxesOverlay = document.getElementById("checkboxesOverlay");
    const checkboxesPopup = document.getElementById("checkboxesPopup");
    const checkboxesContainer = document.getElementById("checkboxesContainer");
    const submitBtn = document.getElementById("submitBtn");
    const lockBtn = document.getElementById("lockBtn");
    const unlockBtn = document.getElementById("unlockBtn");

    // Function to create checkboxes
    function createCheckboxes() {
      checkboxesContainer.innerHTML = "";
      const numColumns = 6;
      const optionsPerColumn = Math.ceil(options.length / numColumns);

      for (let i = 0; i < numColumns; i++) {
        const columnDiv = document.createElement("div");
        columnDiv.classList.add("checkbox-column");

        for (
          let j = i * optionsPerColumn;
          j < (i + 1) * optionsPerColumn && j < options.length;
          j++
        ) {
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.value = options[j];
          checkbox.checked = selectedOptions[j]; // Set checkboxes as selected by default
          const label = document.createElement("label");
          label.textContent = options[j];
          label.prepend(checkbox);
          columnDiv.appendChild(label);
        }

        checkboxesContainer.appendChild(columnDiv);
      }
    }

    // Function to handle checkbox selections
    function handleSubmit() {
      const checkboxes = checkboxesContainer.querySelectorAll(
        'input[type="checkbox"]'
      );
      selectedOptions = [];
      checkboxes.forEach((checkbox) => {
        selectedOptions.push(checkbox.checked);
      });
      console.log("Selected Options:", selectedOptions);
      // Do something with the selected options
      closeOverlay();
    }

    function handleLock() {
      const checkboxes = checkboxesContainer.querySelectorAll(
        'input[type="checkbox"]'
      );
      selectedOptions = [];
      checkboxes.forEach((checkbox) => {
        checkbox.checked = false;
      });
    }

    function handleUnlock() {
      const checkboxes = checkboxesContainer.querySelectorAll(
        'input[type="checkbox"]'
      );
      selectedOptions = [];
      checkboxes.forEach((checkbox) => {
        checkbox.checked = true;
      });
    }

    // Function to open the checkbox overlay
    function openOverlay() {
      createCheckboxes();
      checkboxesOverlay.style.display = "block";
    }

    // Function to close the checkbox overlay
    function closeOverlay() {
      checkboxesOverlay.style.display = "none";
    }

    // Event listeners
    openCheckboxesBtn.addEventListener("click", openOverlay);
    window.addEventListener("click", (event) => {
      if (event.target == checkboxesOverlay) {
        closeOverlay();
      }
    });
    submitBtn.addEventListener("click", handleSubmit);
    lockBtn.addEventListener("click", handleLock);
    unlockBtn.addEventListener("click", handleUnlock);

    window.instantAnalysis = false;

    const anteInput = document.getElementById("ante");
    const cardsPerAnteInput = document.getElementById("cardsPerAnte");
    const deckSelect = document.getElementById("deck");
    const stakeSelect = document.getElementById("stake");
    const versionSelect = document.getElementById("version");
    const omitBeforeAnte9Checkbox = document.getElementById("omitBeforeAnte9");
    const seedInput = document.getElementById("seed");
    const analyzeButton = document.getElementById("analyzeButton");
    const copyLinkButton = document.getElementById("copyButton");
    const downloadButton = document.getElementById("downloadButton");
    const copyButton = document.getElementById("exportButton");
    const summaryToggleButton = document.getElementById(
      "summaryFloatingToggle"
    );
    const summaryFilterToggle = document.getElementById("summaryFilterToggle");
    const summaryFloatingWindow = document.getElementById(
      "summaryFloatingWindow"
    );
    const summaryFloatingContent = document.getElementById(
      "summaryFloatingContent"
    );
    const summaryFilterWindow = document.getElementById("summaryFilterWindow");
    const summaryFilterContent = document.getElementById(
      "summaryFilterContent"
    );
    const withEnglishToggle = document.getElementById("withEnglishToggle");
    const setButtonLoadingState = (btn, flag) => {
      if (!btn) return;
      const isLoading = Boolean(flag);
      btn.disabled = isLoading;
      if (isLoading) {
        // restart CSS spinner animation reliably
        btn.classList.remove("is-loading");
        // force reflow so ::after animation resets
        void btn.offsetWidth;
        btn.classList.add("is-loading");
      } else {
        btn.classList.remove("is-loading");
      }
    };

    // Add event listener for the "Copy Link" button
    copyLinkButton.addEventListener("click", copyLink);

    const summaryFaceEmojiMapRaw =
      (window.BalatroSharedLists &&
        window.BalatroSharedLists.SUMMARY_FACE_EMOJI) ||
      {};

    const jokerTranslations =
      (window.BalatroSharedLists &&
        window.BalatroSharedLists.JOKER_TRANSLATIONS) ||
      {};

    // Build a normalized map: emoji -> { color, cards }
    const summaryFaceEmojiMap = {};
    const summaryFaceCardMap = {};
    Object.entries(summaryFaceEmojiMapRaw).forEach(([emoji, value]) => {
      const color =
        value && typeof value === "object" ? value.color || "" : value || "";
      const cards =
        value && typeof value === "object" && Array.isArray(value.cards)
          ? value.cards
          : [];
      summaryFaceEmojiMap[emoji] = { color, cards };
      cards.forEach((name) => {
        summaryFaceCardMap[name] = { emoji, color };
      });
    });

    window.summaryEmojiFilter = window.summaryEmojiFilter || {};
    Object.keys(summaryFaceEmojiMap).forEach((emoji) => {
      if (!(emoji in window.summaryEmojiFilter)) {
        window.summaryEmojiFilter[emoji] = true;
      }
    });

    function getFaceInfoForSegment(seg) {
      const text = seg || "";
      for (const [cardName, info] of Object.entries(summaryFaceCardMap)) {
        const cnName = jokerTranslations[cardName];
        if (cnName && text.includes(cnName)) {
          return info;
        }
        if (text.includes(cardName)) {
          return info;
        }
      }
      return null;
    }

    function renderSummaryList() {
      if (!summaryFloatingContent) return;
      const map =
        window.lastSummariesByAnte instanceof Map
          ? window.lastSummariesByAnte
          : null;
      summaryFloatingContent.innerHTML = "";

      if (!map || map.size === 0) {
        const empty = document.createElement("div");
        empty.className = "summaryEmpty";
        empty.textContent = "Summary will appear here after you click Analyze.";
        summaryFloatingContent.appendChild(empty);
        return;
      }

      const items = [...map.entries()].sort((a, b) => a[0] - b[0]);
      items.forEach(([anteNum, rawLine], idx) => {
        const item = document.createElement("div");
        item.className = "summaryItem";
        item.dataset.ante = String(anteNum);
        item.dataset.order = String(idx);

        const anteLabel = document.createElement("button");
        anteLabel.type = "button";
        anteLabel.className = "summaryAnteButton";
        anteLabel.textContent = `Ante ${anteNum}`;

        const text = document.createElement("span");
        text.className = "summaryText";
        const cleaned = rawLine
          .replace(/^\s*ante\s*\d+\s*[：:]\s*/i, "")
          .replace(/^\s*\d+\s*[：:]\s*/, "")
          .trim();
        const baseText = cleaned || rawLine;

        // Split summary into segments so we can color only joker items
        const segments = baseText.split(/(、|,)/);
        segments.forEach((seg) => {
          if (!seg) return;
          if (seg === "、" || seg === ",") {
            // delimiter (wrap so we can hide "extra" ones when items are filtered)
            const delimSpan = document.createElement("span");
            delimSpan.className = "summaryDelimiter";
            delimSpan.textContent = seg;
            text.appendChild(delimSpan);
            if (seg === ",") {
              text.appendChild(document.createTextNode(" "));
            }
            return;
          }
          const info = getFaceInfoForSegment(seg);
          if (info) {
            const span = document.createElement("span");
            span.className = "summaryFaceSegment";
            span.dataset.faceEmoji = info.emoji;
            if (info.color) {
              span.style.color = info.color;
            }
            span.textContent = seg;
            text.appendChild(span);
          } else {
            const span = document.createElement("span");
            span.textContent = seg;
            text.appendChild(span);
          }
        });

        const reorderItems = () => {
          const parent = item.parentElement;
          if (!parent) return;
          const children = Array.from(parent.children);
          children.sort((a, b) => {
            const aChecked = a.classList.contains("completed") ? 1 : 0;
            const bChecked = b.classList.contains("completed") ? 1 : 0;
            if (aChecked !== bChecked) return aChecked - bChecked;
            const aOrder = Number(a.dataset.order || 0);
            const bOrder = Number(b.dataset.order || 0);
            return aOrder - bOrder;
          });
          children.forEach((child) => parent.appendChild(child));
        };

        anteLabel.addEventListener("click", () => {
          const anteTarget = Number(item.dataset.ante || anteNum);
          const container = document.getElementById("scrollingContainer");
          const pagination = document.getElementById("paginationContainer");

          // If pagination exists, try to switch to the page containing this ante
          if (pagination && typeof window.goToAntePage === "function") {
            window.goToAntePage(anteTarget);
          }

          // Close the summary window
          const summaryWindow = document.getElementById("summaryFloatingWindow");
          if (summaryWindow) {
            summaryWindow.classList.remove("visible");
          }

          // Scroll to the first queue container whose ante title matches
          requestAnimationFrame(() => {
            const containers = container
              ? container.querySelectorAll(".queueContainer")
              : [];
            let targetNode = null;
            containers.forEach((qc) => {
              if (targetNode) return;
              const titleEl = qc.querySelector(".queueTitle.anteTitle");
              if (!titleEl) return;
              const match =
                titleEl.textContent &&
                titleEl.textContent.match(/ANTE\s*(\d+)/i);
              if (match && Number(match[1]) === anteTarget) {
                targetNode = qc;
              }
            });
            if (targetNode) {
              targetNode.scrollIntoView({
                behavior: "smooth",
                block: "start",
              });
            }
          });
        });

        text.addEventListener("click", () => {
          const nowCompleted = item.classList.toggle("completed");
          text.setAttribute("aria-pressed", nowCompleted ? "true" : "false");
          reorderItems();
        });

        item.append(anteLabel, text);
        summaryFloatingContent.appendChild(item);
      });
    }

    summaryFloatingContent.textContent =
      "Summary will appear here after you click Analyze.";

    function buildSummaryLookup(summaryText) {
      const map = new Map();
      if (!summaryText || !summaryText.trim()) {
        return map;
      }
      summaryText.split("\n").forEach((line) => {
        const trimmed = line.trim();
        if (!trimmed) return;
        // Matches formats like "ANTE 9: ...", "9: ...", or "9： ..."
        const match =
          trimmed.match(/^ante\s*(\d+)\s*[：:]/i) ||
          trimmed.match(/^(\d+)\s*[：:]/);
        if (match) {
          const anteNum = parseInt(match[1], 10);
          if (!Number.isNaN(anteNum) && !map.has(anteNum)) {
            map.set(anteNum, trimmed);
          }
        }
      });
      return map;
    }

    function copyLink() {
      const baseUrl = window.location.origin + window.location.pathname;
      const params = new URLSearchParams();

      // Hash the unlocks
      // Convert the array of booleans to a binary string
      const binaryString = selectedOptions
        .map((unlock) => (unlock ? "1" : "0"))
        .join("");

      // Convert the binary string to a byte array
      const byteArray = [];
      for (let i = 0; i < binaryString.length; i += 8) {
        const byte = parseInt(binaryString.substr(i, 8), 2);
        byteArray.push(byte);
      }

      // Pad the byte array with a null byte if necessary
      if (binaryString.length % 8 !== 0) {
        const paddingBits = "0".repeat(8 - (binaryString.length % 8));
        const paddingByte = parseInt(
          `${binaryString.slice(-binaryString.length % 8)}${paddingBits}`,
          2
        );
        byteArray.push(paddingByte);
      }

      // Encode the byte array to base64
      const base64Unlocks = btoa(String.fromCharCode.apply(null, byteArray));

      // Add non-default input values as URL parameters
      if (anteInput.value !== "39") params.append("ante", anteInput.value);
      if (cardsPerAnteInput.value !== "300")
        params.append("cardsPerAnte", cardsPerAnteInput.value);
      if (deckSelect.value !== "Plasma Deck")
        params.append("deck", deckSelect.value);
      if (stakeSelect.value !== "White Stake")
        params.append("stake", stakeSelect.value);
      if (versionSelect.value !== "10115")
        params.append("version", versionSelect.value);
      if (!omitBeforeAnte9Checkbox.checked)
        params.append("omitBeforeAnte9", "false");
      if (seedInput.value !== "") params.append("seed", seedInput.value);
      if (base64Unlocks != "/////////x/4")
        params.append("unlocks", base64Unlocks);

      const url = `${baseUrl}?${params.toString()}`;

      // Copy the URL to the clipboard
      navigator.clipboard
        .writeText(url)
        .then(() => {
          alert("Link copied to clipboard!");
        })
        .catch((err) => {
          console.error("Failed to copy link: ", err);
        });
    }

    downloadButton.addEventListener("click", () => {
      const filename = seedInput.value + "_analysis.txt";
      const content =
        (window.lastRawOutput && window.lastRawOutput.length
          ? window.lastRawOutput
          : "");

      if (!content) {
        alert("Nothing to download yet.");
        return;
      }

      const blob = new Blob([content], { type: "text/plain" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.click();

      URL.revokeObjectURL(url);
    });

    let balatroAnalysisPromise = null;
    window.lastRawOutput = "";
    window.lastSummary = "";
    window.lastSummariesByAnte = new Map();
    renderSummaryList();
    applySummaryEmojiFilter();
    function ensureBalatroAnalysisLoaded() {
      if (
        window.BalatroAnalysis &&
        typeof window.BalatroAnalysis.summarizeText === "function"
      ) {
        return Promise.resolve(window.BalatroAnalysis);
      }
      if (!balatroAnalysisPromise) {
        balatroAnalysisPromise = new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.src = "balatro_analysis.js";
          script.onload = () => {
            if (
              window.BalatroAnalysis &&
              typeof window.BalatroAnalysis.summarizeText === "function"
            ) {
              resolve(window.BalatroAnalysis);
            } else {
              reject(new Error("BalatroAnalysis helper missing after load."));
            }
          };
          script.onerror = () =>
            reject(new Error("Failed to load balatro_analysis.js"));
          document.head.appendChild(script);
        });
      }
      return balatroAnalysisPromise;
    }

    function buildSummaryFilterUI() {
      if (!summaryFilterContent) return;
      summaryFilterContent.innerHTML = "";

      Object.entries(summaryFaceEmojiMap).forEach(([emoji, color]) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "summaryFilterButton";
        const isOn = window.summaryEmojiFilter[emoji] !== false;
        btn.classList.toggle("active", isOn);

        btn.addEventListener("click", () => {
          const nowOn = !btn.classList.contains("active");
          btn.classList.toggle("active", nowOn);
          window.summaryEmojiFilter[emoji] = nowOn;
          applySummaryEmojiFilter();
        });

        const emojiSpan = document.createElement("span");
        emojiSpan.className = "summaryFilterEmoji";
        emojiSpan.textContent = emoji;
        if (color) {
          emojiSpan.style.color = color;
        }

        btn.appendChild(emojiSpan);
        summaryFilterContent.appendChild(btn);
      });
    }

    summaryToggleButton.addEventListener("click", () => {
      summaryFloatingWindow.classList.toggle("visible");
    });

    if (summaryFilterToggle) {
      summaryFilterToggle.addEventListener("click", (event) => {
        event.stopPropagation();
        if (!summaryFilterWindow) return;
        const nowVisible = !summaryFilterWindow.classList.contains("visible");
        summaryFilterWindow.classList.toggle("visible", nowVisible);
        if (nowVisible) {
          buildSummaryFilterUI();
        }
      });
    }

    // clicking outside filter window closes it
    window.addEventListener("click", (event) => {
      if (!summaryFilterWindow) return;
      if (!summaryFilterWindow.classList.contains("visible")) return;
      const target = event.target;
      if (
        target === summaryFilterWindow ||
        summaryFilterWindow.contains(target) ||
        target === summaryFilterToggle
      ) {
        return;
      }
      summaryFilterWindow.classList.remove("visible");
    });

    function applySummaryEmojiFilter() {
      const emojiMap = summaryFaceEmojiMap || {};
      const filter = window.summaryEmojiFilter || {};
      const isVisible = (emoji) => {
        if (!emoji || !Object.prototype.hasOwnProperty.call(emojiMap, emoji)) {
          return true;
        }
        if (Object.prototype.hasOwnProperty.call(filter, emoji)) {
          return !!filter[emoji];
        }
        return true;
      };

      // Main summary segments
      document
        .querySelectorAll(".summaryText .summaryFaceSegment")
        .forEach((span) => {
          const emoji = span.dataset.faceEmoji || "";
          span.style.display = isVisible(emoji) ? "" : "none";
        });

      // Mini summary items
      document.querySelectorAll(".miniSummaryItem").forEach((span) => {
        const emoji = span.dataset.faceEmoji || "";
        span.style.display = isVisible(emoji) ? "" : "none";
      });

      // Queue / pack items (card set area)
      document
        .querySelectorAll(
          ".queueItem[data-face-emoji], .packItem > div[data-face-emoji]"
        )
        .forEach((el) => {
          const emoji = el.dataset.faceEmoji || "";
          const visible = isVisible(emoji);
          el.classList.toggle("emojiFilterOff", !visible);
        });

      // Hide mini summary rows with no visible items
      document.querySelectorAll(".miniSummaryEntry").forEach((row) => {
        const items = row.querySelectorAll(".miniSummaryItem");
        if (!items.length) {
          row.style.display = "";
          return;
        }
        const hasVisible = Array.from(items).some(
          (item) => item.style.display !== "none"
        );
        row.style.display = hasVisible ? "" : "none";
      });

      // Hide "extra" delimiters in main summary (leading/trailing or around hidden items)
      document
        .querySelectorAll(".summaryText .summaryDelimiter")
        .forEach((delim) => {
          const prev = delim.previousElementSibling;
          const next = delim.nextElementSibling;
          const prevVisible =
            prev &&
            prev !== delim &&
            prev.style.display !== "none" &&
            !prev.classList.contains("summaryDelimiter");
          const nextVisible =
            next &&
            next !== delim &&
            next.style.display !== "none" &&
            !next.classList.contains("summaryDelimiter");
          delim.style.display = prevVisible && nextVisible ? "" : "none";
        });

      // Hide "extra" delimiters in mini summaries (leading/trailing or around hidden items)
      document
        .querySelectorAll(".miniSummaryText .miniSummaryDelimiter")
        .forEach((delim) => {
          const prev = delim.previousElementSibling;
          const next = delim.nextElementSibling;
          const prevVisible =
            prev &&
            prev.classList.contains("miniSummaryItem") &&
            prev.style.display !== "none";
          const nextVisible =
            next &&
            next.classList.contains("miniSummaryItem") &&
            next.style.display !== "none";
          delim.style.display = prevVisible && nextVisible ? "" : "none";
        });
    }

    window.applySummaryEmojiFilter = applySummaryEmojiFilter;

    function summarizeOutput(sourceButton) {
      const rawText =
        (window.lastRawOutput && window.lastRawOutput.length
          ? window.lastRawOutput
          : "") || "";

      if (!rawText) {
        alert("Nothing to summarize yet.");
        return Promise.resolve();
      }

      if (summaryFloatingContent) {
        summaryFloatingContent.textContent = "Summarizing results...";
      }

      const withEnglish = withEnglishToggle ? withEnglishToggle.checked : true;
      const summaryOptions = withEnglish ? {} : { chineseOnly: true };

      if (sourceButton) {
        setButtonLoadingState(sourceButton, true);
      }

      return ensureBalatroAnalysisLoaded()
        .then((balatro) => {
          const summary = balatro.summarizeText(rawText, summaryOptions);
          const finalSummary = summary || rawText;
          window.lastSummary = finalSummary;
          window.lastSummariesByAnte = buildSummaryLookup(finalSummary);
          renderSummaryList();
          applySummaryEmojiFilter();
        })
        .catch((err) => {
          console.error("Failed to run balatro_analysis:", err);
          window.lastSummary = rawText;
          window.lastSummariesByAnte = buildSummaryLookup(rawText);
          renderSummaryList();
          applySummaryEmojiFilter();
        })
        .finally(() => {
          if (sourceButton) {
            setButtonLoadingState(sourceButton, false);
          }
        });
    }

    copyButton.addEventListener("click", () => {
      summarizeOutput(copyButton);
    });

    // Add event listener to the "Analysis" button
    analyzeButton.addEventListener("click", performAnalysis);

    function createImmolateInstance(seed, deck, stake, version) {
      const inst = new Immolate.Instance(seed);
      inst.params = new Immolate.InstParams(deck, stake, false, version);
      inst.initLocks(1, false, false);
      inst.lock("Overstock Plus");
      inst.lock("Liquidation");
      inst.lock("Glow Up");
      inst.lock("Reroll Glut");
      inst.lock("Omen Globe");
      inst.lock("Observatory");
      inst.lock("Nacho Tong");
      inst.lock("Recyclomancy");
      inst.lock("Tarot Tycoon");
      inst.lock("Planet Tycoon");
      inst.lock("Money Tree");
      inst.lock("Antimatter");
      inst.lock("Illusion");
      inst.lock("Petroglyph");
      inst.lock("Retcon");
      inst.lock("Palette");
      for (let i = 0; i < options.length; i++) {
        if (selectedOptions[i] == false) inst.lock(options[i]);
      }
      inst.setStake(stake);
      inst.setDeck(deck);
      return inst;
    }

    function performAnalysis() {
      // Get input values
      const ante = parseInt(anteInput.value, 10);
      const cardsPerAnte = Array(ante).fill(Number(cardsPerAnteInput.value));
      const deck = deckSelect.value;
      const stake = stakeSelect.value;
      const version = parseInt(versionSelect.value);
      const seed = seedInput.value.toUpperCase().replace(/0/g, "O");

      output = "";

      // show loading spinner on analyze button
      setButtonLoadingState(analyzeButton, true);

      if (window.setGroupButtonsLoading) {
        window.setGroupButtonsLoading(true);
      }

      const runAnalysis = () => {
        const inst = createImmolateInstance(seed, deck, stake, version);
        const omitBeforeAnte9 = omitBeforeAnte9Checkbox.checked;
        for (let a = 1; a <= ante; a++) {
          inst.initUnlocks(a, false);
          const shouldOutput = !(omitBeforeAnte9 && a < 9);
          const addOutput = shouldOutput
            ? (text) => {
                output += text;
              }
            : () => {};
          addOutput("==ANTE " + a + "==\n");
          addOutput("Boss: " + inst.nextBoss(a) + "\n");
          var voucher = inst.nextVoucher(a);
          addOutput("Voucher: " + voucher + "\n");
          inst.lock(voucher);
          // Unlock next level voucher
          for (let i = 0; i < Immolate.VOUCHERS.size(); i += 2) {
            if (Immolate.VOUCHERS.get(i) == voucher) {
              if (selectedOptions[options.indexOf(Immolate.VOUCHERS.get(i + 1))]) {
                inst.unlock(Immolate.VOUCHERS.get(i + 1));
              }
            }
          }
          addOutput("Tags: " + inst.nextTag(a) + ", " + inst.nextTag(a) + "\n");

          addOutput("Shop Queue: \n");
          for (let q = 1; q <= cardsPerAnte[a - 1]; q++) {
            addOutput(q + ") ");
            var item = inst.nextShopItem(a);
            if (item.type == "Joker") {
              if (item.jokerData.stickers.eternal) addOutput("Eternal ");
              if (item.jokerData.stickers.perishable) addOutput("Perishable ");
              if (item.jokerData.stickers.rental) addOutput("Rental ");
              if (item.jokerData.edition != "No Edition")
                addOutput(item.jokerData.edition + " ");
            }
            addOutput(item.item + "\n");
            item.delete();
          }

          addOutput("\nPacks: \n");
          var numPacks = a == 1 ? 4 : 6;
          for (let p = 1; p <= numPacks; p++) {
            var pack = inst.nextPack(a);
            addOutput(pack + " - ");
            var packInfo = Immolate.packInfo(pack);
            if (packInfo.type == "Celestial Pack") {
              var cards = inst.nextCelestialPack(packInfo.size, a);
              for (let c = 0; c < packInfo.size; c++) {
                addOutput(cards.get(c));
                addOutput(c + 1 != packInfo.size ? ", " : "");
              }
              cards.delete();
            }
            if (packInfo.type == "Arcana Pack") {
              var cards = inst.nextArcanaPack(packInfo.size, a);
              for (let c = 0; c < packInfo.size; c++) {
                addOutput(cards.get(c));
                addOutput(c + 1 != packInfo.size ? ", " : "");
              }
              cards.delete();
            }
            if (packInfo.type == "Spectral Pack") {
              var cards = inst.nextSpectralPack(packInfo.size, a);
              for (let c = 0; c < packInfo.size; c++) {
                addOutput(cards.get(c));
                addOutput(c + 1 != packInfo.size ? ", " : "");
              }
              cards.delete();
            }
            if (packInfo.type == "Buffoon Pack") {
              var cards = inst.nextBuffoonPack(packInfo.size, a);
              for (let c = 0; c < packInfo.size; c++) {
                var joker = cards.get(c);
                if (joker.stickers.eternal) addOutput("Eternal ");
                if (joker.stickers.perishable) addOutput("Perishable ");
                if (joker.stickers.rental) addOutput("Rental ");
                if (joker.edition != "No Edition") addOutput(joker.edition + " ");
                addOutput(joker.joker);
                addOutput(c + 1 != packInfo.size ? ", " : "");
                joker.delete();
              }
              cards.delete();
            }
            if (packInfo.type == "Standard Pack") {
              var cards = inst.nextStandardPack(packInfo.size, a);
              for (let c = 0; c < packInfo.size; c++) {
                var card = cards.get(c);
                if (card.seal != "No Seal") addOutput(card.seal + " ");
                if (card.edition != "No Edition") addOutput(card.edition + " ");
                if (card.enhancement != "No Enhancement")
                  addOutput(card.enhancement + " ");
                var rank = card.base[2];
                if (rank == "T") addOutput("10");
                else if (rank == "J") addOutput("Jack");
                else if (rank == "Q") addOutput("Queen");
                else if (rank == "K") addOutput("King");
                else if (rank == "A") addOutput("Ace");
                else addOutput(rank);
                addOutput(" of ");
                var suit = card.base[0];
                if (suit == "C") addOutput("Clubs");
                else if (suit == "S") addOutput("Spades");
                else if (suit == "D") addOutput("Diamonds");
                else if (suit == "H") addOutput("Hearts");
                addOutput(c + 1 != packInfo.size ? ", " : "");
                card.delete();
              }
              cards.delete();
            }
            addOutput("\n");
          }

          addOutput("\n");
        }

        inst.delete();

        window.lastRawOutput = output;

        summarizeOutput()
          .finally(() => {
            setButtonLoadingState(analyzeButton, false);
            if (window.setGroupButtonsLoading) {
              window.setGroupButtonsLoading(false);
            }
            window.pendingScrollToResults = true;
            if (window.refreshShopDisplay) {
              window.refreshShopDisplay();
            } else {
              const container = document.getElementById("scrollingContainer");
              if (container) {
                container.scrollIntoView({
                  behavior: "smooth",
                  block: "start",
                });
              }
            }
          });
      };

      // defer heavy work so the spinner can paint first
      setTimeout(runAnalysis, 0);
    }

    function computeSingleAnteQueue(targetAnte, cardsLimit) {
      const deck = deckSelect.value;
      const stake = stakeSelect.value;
      const version = parseInt(versionSelect.value);
      const seed = seedInput.value.toUpperCase().replace(/0/g, "O");
      const anteNum = Number(targetAnte);
      const limit = Math.max(0, Number(cardsLimit) || 0);
      if (!Number.isFinite(anteNum) || anteNum < 1 || !limit) {
        return [];
      }
      if (typeof Immolate === "undefined" || !Immolate.Instance) {
        console.error("Immolate wasm not ready for single-ante compute.");
        return [];
      }

      const inst = createImmolateInstance(seed, deck, stake, version);
      inst.initUnlocks(anteNum, false);

      const lines = [];
      for (let q = 1; q <= limit; q++) {
        const item = inst.nextShopItem(anteNum);

        let line = `${q}) `;
        if (item.type === "Joker" && item.jokerData) {
          // keep sticker labels
          if (item.jokerData.stickers.eternal) line += "Eternal ";
          if (item.jokerData.stickers.perishable) line += "Perishable ";
          if (item.jokerData.stickers.rental) line += "Rental ";

          // In this per-ante view only show a Negative "tag" marker and
          // do not display other editions like Foil/Holographic/Polychrome.
          const isNegativeEdition = item.jokerData.edition === "Negative";
          const namePrefix = isNegativeEdition ? "‼️ " : "";
          line += namePrefix + item.item;
        } else {
          line += item.item;
        }

        lines.push(line);
        item.delete();
      }

      inst.delete();
      return lines;
    }

    window.computeSingleAnteQueue = computeSingleAnteQueue;

    window.addEventListener("DOMContentLoaded", () => {
      const seedInput = document.getElementById("seed");
      const cardsPerAnteInput = document.getElementById("cardsPerAnte");
      const anteInput = document.getElementById("ante");
      const deckInput = document.getElementById("deck");
      const stakeInput = document.getElementById("stake");
      const versionInput = document.getElementById("version");

      // Get seed value from URL parameters
      const urlParams = new URLSearchParams(window.location.search);
      const urlSeed = urlParams.get("seed");
      const urlAnte = urlParams.get("ante");
      const urlCardsPerAnte = urlParams.get("cardsPerAnte");
      const urlDeck = urlParams.get("deck");
      const urlStake = urlParams.get("stake");
      const urlVersion = urlParams.get("version");
      const urlOmitBeforeAnte9 = urlParams.get("omitBeforeAnte9");
      const urlUnlocks = urlParams.get("unlocks");

      if (urlUnlocks) {
        // Decode the base64 string
        const binaryString = atob(urlUnlocks)
          .split("")
          .map((char) => char.charCodeAt(0).toString(2).padStart(8, "0"))
          .join("");

        // Remove the padding byte (if present)
        const paddingLength = binaryString.length % 8;
        const unpadded =
          paddingLength > 0
            ? binaryString.slice(0, -paddingLength)
            : binaryString;

        // Convert the binary string back to an array of booleans
        const decodedUnlocks = unpadded.split("").map((bit) => bit === "1");
        selectedOptions = decodedUnlocks;
      }

      // Set default seed value
      if (urlAnte) {
        anteInput.value = urlAnte;
        anteInput.value = Math.min(anteInput.value, 999);
        anteInput.value = Math.max(anteInput.value, 1);
        cardsPerAnteInput.value = Array(anteInput.value).fill(
          Number(urlCardsPerAnte ? urlCardsPerAnte : "300")
        );
      }
      if (urlCardsPerAnte) {
        cardsPerAnteInput.value = Array(anteInput.value).fill(
          Number(urlCardsPerAnte)
        );
      }
      if (urlDeck) {
        deckInput.value = urlDeck;
      }
      if (urlStake) {
        stakeInput.value = urlStake;
      }
      if (urlSeed) {
        seedInput.value = filterSeed(urlSeed);
        window.instantAnalysis = true;
      }
      if (urlVersion) {
        versionInput.value = urlVersion;
      }
      if (urlOmitBeforeAnte9 !== null) {
        omitBeforeAnte9Checkbox.checked =
          urlOmitBeforeAnte9 !== "false" && urlOmitBeforeAnte9 !== "0";
      }

      // Add event listener for input event
      seedInput.addEventListener("input", () => {
        seedInput.value = filterSeed(seedInput.value);
      });

      anteInput.addEventListener("input", () => {
        anteInput.value = Math.min(anteInput.value, 999);
        anteInput.value = Math.max(anteInput.value, 1);
      });

      cardsPerAnteInput.addEventListener("input", () => {
        cardsPerAnteInput.value = Math.min(cardsPerAnteInput.value, 999);
        cardsPerAnteInput.value = Math.max(cardsPerAnteInput.value, 0);
        cardsPerAnteInput.value = Array(anteInput.value).fill(
          Number(cardsPerAnteInput.value)
        );
      });

      function filterSeed(seed) {
        const filteredSeed = seed
          .replace(/[^A-Za-z0-9]/g, "")
          .toUpperCase()
          .replace(/0/g, "O");

        // Truncate the seed if it's longer than 8 characters
        return filteredSeed.slice(0, 8);
      }
    });
  </script>
</html>
