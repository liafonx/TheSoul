<!DOCTYPE html>
<html>
  <script>
    (function initializeLocalePreference() {
      var fallbackLocale = "zh-CN";
      try {
        var saved = localStorage.getItem("balatro.locale");
        window.__BALATRO_LOCALE__ = (saved === "en-US" || saved === "zh-CN") ? saved : fallbackLocale;
      } catch (_err) {
        window.__BALATRO_LOCALE__ = fallbackLocale;
      }
    })();

    var Immolate = {
      onRuntimeInitialized: function () {
        if (window.instantAnalysis) {
          performAnalysis();
        }
      },
    };

    // Helper function for vectors
    function asVector(arr) {
      var vectorInt = new Module.VectorStr();
      for (var i = 0; i < arr.length; i++) {
        vectorInt.push_back(arr[i]);
      }
      return vectorInt;
    }
  </script>
  <script src="immolate.js"></script>
  <script>
    (function loadLocalizationScripts() {
      var isLocal = /^(localhost|127\.0\.0\.1)$/.test(window.location.hostname);
      var version = isLocal ? String(Date.now()) : "1";
      window.__ASSET_VERSION__ = version;
      [
        "localization/generated/zh-CN.game.js",
        "localization/ui-zh-CN.js",
        "localization/i18n.global.js",
        "balatro_lists.js",
      ].forEach(function (src) {
        document.write('<script src="' + src + "?v=" + version + '"><' + "/script>");
      });
    })();
  </script>
  <script>
    (function loadUiScript() {
      var version = window.__ASSET_VERSION__ || "1";
      document.write('<script src="UI.js?v=' + version + '" defer><' + "/script>");
    })();
  </script>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Soul</title>
    <script>
      (function loadStyleSheets() {
        var version = window.__ASSET_VERSION__ || "1";
        document.write('<link rel="stylesheet" href="base.css?v=' + version + '">');
        document.write('<link rel="stylesheet" href="ui.css?v=' + version + '">');
      })();
    </script>
    <link rel="icon" type="image/png" href="images/icon.ico" />
  </head>
  <body>
    <h1 class="site-title">
      <div id="localeToggleContainer">
        <button id="localeToggleButton" type="button" aria-label="Toggle language">EN</button>
        <button id="emojiLegendButton" type="button" aria-label="Show emoji legend">Emoji Legend</button>
      </div>
      <img src="images/icon.ico" alt="The Soul icon" class="site-title-icon" width="48" height="48" />
      <span>The Soul</span>
    </h1>
    <div class="container">
      <div class="input-section">
        <h2>Config Analyze</h2>

        <div class="settings-grid">
          <div class="settings-field">
            <label for="seed">Seed:</label>
            <input type="text" id="seed" maxlength="8" pattern="[A-Z1-9]{1,8}" class="settings-core-input" required />
          </div>

          <div class="settings-field">
            <label for="ante">Max Ante:</label>
            <input type="number" id="ante" min="1" max="39" class="settings-core-input" value="39" required />
          </div>

          <div class="settings-field">
            <label for="cardsPerAnte">Cards per Ante:</label>
            <input type="number" id="cardsPerAnte" min="0" max="999" value="300" class="settings-core-input" required />
          </div>

          <div class="settings-field">
            <label for="deck">Deck:</label>
            <select id="deck" required>
              <option value="Red Deck">Red Deck</option>
              <option value="Blue Deck">Blue Deck</option>
              <option value="Yellow Deck">Yellow Deck</option>
              <option value="Green Deck">Green Deck</option>
              <option value="Black Deck">Black Deck</option>
              <option value="Magic Deck">Magic Deck</option>
              <option value="Nebula Deck">Nebula Deck</option>
              <option value="Ghost Deck">Ghost Deck</option>
              <option value="Abandoned Deck">Abandoned Deck</option>
              <option value="Checkered Deck">Checkered Deck</option>
              <option value="Zodiac Deck">Zodiac Deck</option>
              <option value="Painted Deck">Painted Deck</option>
              <option value="Anaglyph Deck">Anaglyph Deck</option>
              <option value="Plasma Deck" selected>Plasma Deck</option>
              <option value="Erratic Deck">Erratic Deck</option>
            </select>
          </div>

          <div class="settings-field">
            <label for="stake">Stake:</label>
            <select id="stake" required>
              <option value="White Stake">White Stake</option>
              <option value="Red Stake">Red Stake</option>
              <option value="Green Stake">Green Stake</option>
              <option value="Black Stake">Black Stake</option>
              <option value="Blue Stake">Blue Stake</option>
              <option value="Purple Stake">Purple Stake</option>
              <option value="Orange Stake">Orange Stake</option>
              <option value="Gold Stake">Gold Stake</option>
            </select>
          </div>

          <div class="settings-field">
            <label for="version">Version:</label>
            <select id="version" required>
              <option value="10115">1.0.1o-full</option>
              <option value="10014">1.0.0n</option>
              <option value="10106">1.0.1f</option>
              <option value="10103">1.0.1c</option>
            </select>
          </div>
        </div>

        <div class="checkbox-row">
          <input type="checkbox" id="omitBeforeAnte9" checked />
          <label for="omitBeforeAnte9">Omit results before Ante 9</label>
        </div>

        <div class="settings-actions">
          <button id="analyzeButton">Analyze</button>
          <button id="openCheckboxesBtn">Modify Unlocks</button>
          <button id="copyButton">Copy Link</button>
          <button id="downloadButton">Download output</button>
          <button id="exportButton">Copy Summary</button>
        </div>

        <div id="checkboxesOverlay">
          <div id="checkboxesPopup">
            <h2>Unlocked Items</h2>
            <div id="checkboxesContainer"></div>
            <div class="unlock-actions">
              <button id="submitBtn">Submit</button>
              <button id="unlockBtn">Unlock All</button>
              <button id="lockBtn">Lock All</button>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="summaryFloatingWindow">
      <div id="summaryFloatingContent" aria-live="polite"></div>
    </div>
    <div id="summaryFilterWindow">
      <div id="summaryFilterContent"></div>
    </div>
    <div id="emojiLegendWindow">
      <div id="emojiLegendContent"></div>
    </div>
    <div id="summaryButtons">
      <button id="summaryFloatingToggle" type="button">Summary</button>
      <button id="summaryFilterToggle" type="button">Settings</button>
    </div>
  </body>
  <script>
    // Unlocks configuration
    const options = [
      "Negative Tag", "Foil Tag", "Holographic Tag", "Polychrome Tag", "Rare Tag",
      "Golden Ticket", "Mr. Bones", "Acrobat", "Sock and Buskin", "Swashbuckler",
      "Troubadour", "Certificate", "Smeared Joker", "Throwback", "Hanging Chad",
      "Rough Gem", "Bloodstone", "Arrowhead", "Onyx Agate", "Glass Joker",
      "Showman", "Flower Pot", "Blueprint", "Wee Joker", "Merry Andy",
      "Oops! All 6s", "The Idol", "Seeing Double", "Matador", "Hit the Road",
      "The Duo", "The Trio", "The Family", "The Order", "The Tribe",
      "Stuntman", "Invisible Joker", "Brainstorm", "Satellite", "Shoot the Moon",
      "Drivers License", "Cartomancer", "Astronomer", "Burnt Joker", "Bootstraps",
      "Overstock Plus", "Liquidation", "Glow Up", "Reroll Glut", "Omen Globe",
      "Observatory", "Nacho Tong", "Recyclomancy", "Tarot Tycoon", "Planet Tycoon",
      "Money Tree", "Antimatter", "Illusion", "Petroglyph", "Retcon", "Palette",
    ];
    let selectedOptions = Array(61).fill(true);

    // DOM references
    const openCheckboxesBtn = document.getElementById("openCheckboxesBtn");
    const checkboxesOverlay = document.getElementById("checkboxesOverlay");
    const checkboxesContainer = document.getElementById("checkboxesContainer");
    const submitBtn = document.getElementById("submitBtn");
    const lockBtn = document.getElementById("lockBtn");
    const unlockBtn = document.getElementById("unlockBtn");

    // Checkbox management
    function createCheckboxes() {
      checkboxesContainer.innerHTML = "";

      options.forEach((optionName, index) => {
        const row = document.createElement("div");
        row.className = "unlock-item";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = optionName;
        checkbox.checked = Boolean(selectedOptions[index]);
        checkbox.dataset.index = String(index);
        checkbox.id = `unlockOption_${index}`;

        const label = document.createElement("label");
        label.setAttribute("for", checkbox.id);
        label.textContent = t(optionName);

        row.append(checkbox, label);
        checkboxesContainer.appendChild(row);
      });
    }

    function handleSubmit() {
      const checkboxes = checkboxesContainer.querySelectorAll('input[type="checkbox"]');
      const next = Array(options.length).fill(false);
      checkboxes.forEach((checkbox) => {
        const idx = Number(checkbox.dataset.index);
        if (Number.isInteger(idx) && idx >= 0 && idx < next.length) {
          next[idx] = checkbox.checked;
        }
      });
      selectedOptions = next;
      closeOverlay();
    }

    function handleLock() {
      checkboxesContainer.querySelectorAll('input[type="checkbox"]').forEach((cb) => (cb.checked = false));
    }

    function handleUnlock() {
      checkboxesContainer.querySelectorAll('input[type="checkbox"]').forEach((cb) => (cb.checked = true));
    }

    function openOverlay() {
      createCheckboxes();
      checkboxesOverlay.style.display = "block";
    }

    function closeOverlay() {
      checkboxesOverlay.style.display = "none";
    }

    openCheckboxesBtn.addEventListener("click", openOverlay);
    window.addEventListener("click", (e) => e.target === checkboxesOverlay && closeOverlay());
    submitBtn.addEventListener("click", handleSubmit);
    lockBtn.addEventListener("click", handleLock);
    unlockBtn.addEventListener("click", handleUnlock);

    // Initialize state
    window.instantAnalysis = false;
    window.lastRawOutput = "";
    window.lastSummary = "";
    window.lastSummariesByAnte = new Map();

    // DOM elements
    const anteInput = document.getElementById("ante");
    const cardsPerAnteInput = document.getElementById("cardsPerAnte");
    const deckSelect = document.getElementById("deck");
    const stakeSelect = document.getElementById("stake");
    const versionSelect = document.getElementById("version");
    const omitBeforeAnte9Checkbox = document.getElementById("omitBeforeAnte9");
    const seedInput = document.getElementById("seed");
    const analyzeButton = document.getElementById("analyzeButton");
    const copyLinkButton = document.getElementById("copyButton");
    const downloadButton = document.getElementById("downloadButton");
    const exportButton = document.getElementById("exportButton");
    const summaryToggleButton = document.getElementById("summaryFloatingToggle");
    const summaryFilterToggle = document.getElementById("summaryFilterToggle");
    const summaryFloatingWindow = document.getElementById("summaryFloatingWindow");
    const summaryFloatingContent = document.getElementById("summaryFloatingContent");
    const summaryFilterWindow = document.getElementById("summaryFilterWindow");
    const summaryFilterContent = document.getElementById("summaryFilterContent");
    const emojiLegendWindow = document.getElementById("emojiLegendWindow");
    const emojiLegendContent = document.getElementById("emojiLegendContent");
    const localeToggleButton = document.getElementById("localeToggleButton");
    const emojiLegendButton = document.getElementById("emojiLegendButton");

    // Helper to get utils (loaded later by UI.js)
    const getUtils = () => window.BalatroUtils || {};
    const t = (key) => window.BalatroI18n?.t ? window.BalatroI18n.t(key) : key;

    function applyUiLocalization() {
      const settingsHeader = document.querySelector(".input-section h2");
      if (settingsHeader) settingsHeader.textContent = t("Config Analyze");

      const setText = (selector, text) => {
        const el = document.querySelector(selector);
        if (el) el.textContent = text;
      };
      const localizeSelectOptions = (selectEl) => {
        if (!selectEl) return;
        Array.from(selectEl.options || []).forEach((option) => {
          option.textContent = t(option.value || option.textContent || "");
        });
      };

      setText('label[for="seed"]', t("Seed:"));
      setText('label[for="ante"]', t("Max Ante:"));
      setText('label[for="cardsPerAnte"]', t("Cards per Ante:"));
      setText('label[for="deck"]', t("Deck:"));
      setText('label[for="stake"]', t("Stake:"));
      setText('label[for="version"]', t("Version:"));
      setText('label[for="omitBeforeAnte9"]', t("Omit results before Ante 9"));

      if (analyzeButton) analyzeButton.textContent = t("Analyze");
      if (openCheckboxesBtn) openCheckboxesBtn.textContent = t("Modify Unlocks");
      if (copyLinkButton) copyLinkButton.textContent = t("Copy Link");
      if (downloadButton) downloadButton.textContent = t("Download output");
      if (exportButton) exportButton.textContent = t("Copy Summary");
      if (summaryToggleButton) summaryToggleButton.textContent = t("Summary");
      if (summaryFilterToggle) summaryFilterToggle.textContent = t("Settings");

      setText("#checkboxesPopup h2", t("Unlocked Items"));
      if (submitBtn) submitBtn.textContent = t("Submit");
      if (unlockBtn) unlockBtn.textContent = t("Unlock All");
      if (lockBtn) lockBtn.textContent = t("Lock All");

      if (checkboxesOverlay && checkboxesOverlay.style.display === "block") {
        createCheckboxes();
      }

      localizeSelectOptions(deckSelect);
      localizeSelectOptions(stakeSelect);

      const localeNow = window.BalatroI18n?.getLocale?.() || window.__BALATRO_LOCALE__ || "zh-CN";
      if (localeToggleButton) {
        const switchToEnglish = localeNow === "zh-CN";
        localeToggleButton.textContent = switchToEnglish ? "EN" : "ä¸­æ–‡";
        localeToggleButton.title = switchToEnglish ? "Switch to English" : "åˆ‡æ¢åˆ°ä¸­æ–‡";
      }
      if (emojiLegendButton) {
        emojiLegendButton.textContent = t("Emoji Legend");
        emojiLegendButton.title = t("Emoji Legend");
      }
      if (emojiLegendWindow?.classList.contains("visible")) {
        if (emojiLegendWindow.classList.contains("visible")) {
          emojiLegendWindow.classList.remove("visible");
        }
        buildEmojiLegendUI();
      }
      if (summaryFilterWindow?.classList.contains("visible")) {
        buildSummaryFilterUI();
      }
    }

    // Summary window visibility
    const setSummaryFloatingVisible = (flag) => {
      if (!summaryFloatingWindow) return;
      summaryFloatingWindow.classList.toggle("visible", Boolean(flag));
      document.body.classList.toggle("summary-floating-open", Boolean(flag));
    };

    // Button loading state (uses shared util when available)
    const setButtonLoadingState = (btn, flag) => {
      const utils = getUtils();
      if (utils.setButtonLoadingState) {
        utils.setButtonLoadingState(btn, flag);
      } else if (btn) {
        btn.disabled = Boolean(flag);
        btn.classList.toggle("is-loading", Boolean(flag));
      }
    };

    // Copy link functionality
    function copyLink() {
      const baseUrl = window.location.origin + window.location.pathname;
      const params = new URLSearchParams();

      // Encode unlocks as base64
      const binaryString = selectedOptions.map((u) => (u ? "1" : "0")).join("");
      const byteArray = [];
      for (let i = 0; i < binaryString.length; i += 8) {
        byteArray.push(parseInt(binaryString.substr(i, 8).padEnd(8, "0"), 2));
      }
      const base64Unlocks = btoa(String.fromCharCode.apply(null, byteArray));

      if (anteInput.value !== "39") params.append("ante", anteInput.value);
      if (cardsPerAnteInput.value !== "300") params.append("cardsPerAnte", cardsPerAnteInput.value);
      if (deckSelect.value !== "Plasma Deck") params.append("deck", deckSelect.value);
      if (stakeSelect.value !== "White Stake") params.append("stake", stakeSelect.value);
      if (versionSelect.value !== "10115") params.append("version", versionSelect.value);
      if (!omitBeforeAnte9Checkbox.checked) params.append("omitBeforeAnte9", "false");
      if (seedInput.value !== "") params.append("seed", seedInput.value);
      if (base64Unlocks !== "/////////x/4") params.append("unlocks", base64Unlocks);

      navigator.clipboard.writeText(`${baseUrl}?${params.toString()}`)
        .then(() => alert(t("Link copied to clipboard!")))
        .catch((err) => console.error("Failed to copy link:", err));
    }

    copyLinkButton.addEventListener("click", copyLink);

    // Locale toggle
    localeToggleButton?.addEventListener("click", () => {
      const localeNow = window.BalatroI18n?.getLocale?.() || window.__BALATRO_LOCALE__ || "zh-CN";
      const nextLocale = localeNow === "zh-CN" ? "en-US" : "zh-CN";
      try {
        localStorage.setItem("balatro.locale", nextLocale);
      } catch (_err) {
        // Ignore storage failures; reload still picks fallback.
      }
      window.__BALATRO_LOCALE__ = nextLocale;
      window.location.reload();
    });

    // Download output
    downloadButton.addEventListener("click", () => {
      const content = window.lastRawOutput || "";
      if (!content) {
        alert(t("Nothing to download yet."));
        return;
      }
      const blob = new Blob([content], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = seedInput.value + "_analysis.txt";
      a.click();
      URL.revokeObjectURL(url);
    });

    // Summary rendering
    function buildSummaryLookup(summaryText) {
      const map = new Map();
      if (!summaryText?.trim()) return map;
      summaryText.split("\n").forEach((line) => {
        const trimmed = line.trim();
        if (!trimmed) return;
        const match = trimmed.match(/^ante\s*(\d+)\s*[ï¼š:]/i) || trimmed.match(/^(\d+)\s*[ï¼š:]/);
        if (match) {
          const anteNum = parseInt(match[1], 10);
          if (!Number.isNaN(anteNum) && !map.has(anteNum)) map.set(anteNum, trimmed);
        }
      });
      return map;
    }

    function renderSummaryList() {
      if (!summaryFloatingContent) return;
      const utils = getUtils();
      const map = window.lastSummariesByAnte;
      summaryFloatingContent.innerHTML = "";

      if (!map?.size) {
        summaryFloatingContent.appendChild(Object.assign(document.createElement("div"), { className: "summaryEmpty", textContent: t("Summary will appear here after you click Analyze.") }));
        return;
      }

      // Helper to render segments with delimiters and face coloring
      const renderSegments = (baseText, container) => {
        baseText.split(/(ã€|,)/).forEach((seg) => {
          if (!seg) return;
          if (seg === "ã€" || seg === ",") {
            container.appendChild(Object.assign(document.createElement("span"), { className: "summaryDelimiter", textContent: seg }));
            if (seg === ",") container.appendChild(document.createTextNode(" "));
            return;
          }
          seg.split(/(\|)/).forEach((chunk) => {
            if (!chunk) return;
            if (chunk === "|") { container.appendChild(Object.assign(document.createElement("span"), { className: "summaryPipe", textContent: " | " })); return; }
            const span = document.createElement("span");
            span.textContent = chunk;
            span.dataset.originalText = chunk;
            const info = utils.getFaceInfoForSegment?.(chunk);
            if (info) {
              span.className = "summaryFaceSegment";
              span.dataset.faceEmoji = info.emoji;
              chunk.includes("â€¼ï¸") ? span.classList.add("negativeFace") : info.color && (span.style.color = info.color);
            }
            const summaryEmojis = utils.getSummaryEmojisForText?.(chunk) || [];
            if (summaryEmojis.length) {
              span.dataset.summaryEmojis = summaryEmojis.join(",");
            }
            container.appendChild(span);
          });
        });
      };

      [...map.entries()].sort((a, b) => a[0] - b[0]).forEach(([anteNum, rawLine], idx) => {
        const item = Object.assign(document.createElement("div"), { className: "summaryItem" });
        item.dataset.ante = String(anteNum);
        item.dataset.order = String(idx);

        const anteLabel = Object.assign(document.createElement("button"), { type: "button", className: "summaryAnteButton", textContent: `Ante ${anteNum}` });
        const text = Object.assign(document.createElement("span"), { className: "summaryText" });
        renderSegments((utils.cleanSummaryLine || ((x) => x))(rawLine) || rawLine, text);

        anteLabel.addEventListener("click", () => {
          window.goToAntePage?.(anteNum);
          setSummaryFloatingVisible(false);
          requestAnimationFrame(() => {
            const target = [...(document.getElementById("scrollingContainer")?.querySelectorAll(".queueContainer") || [])].find((qc) => qc.querySelector(".queueTitle.anteTitle")?.textContent?.match(/ANTE\s*(\d+)/i)?.[1] == anteNum);
            target?.scrollIntoView({ behavior: "smooth", block: "start" });
          });
        });

        text.addEventListener("dblclick", () => {
          text.setAttribute("aria-pressed", item.classList.toggle("completed") ? "true" : "false");
          const parent = item.parentElement;
          if (parent) [...parent.children].sort((a, b) => (a.classList.contains("completed") ? 1 : 0) - (b.classList.contains("completed") ? 1 : 0) || (Number(a.dataset.order) || 0) - (Number(b.dataset.order) || 0)).forEach((c) => parent.appendChild(c));
        });

        item.append(anteLabel, text);
        summaryFloatingContent.appendChild(item);
      });
    }

    summaryFloatingContent.textContent = t("Summary will appear here after you click Analyze.");

    // Summary filter UI
    function buildSummaryFilterUI() {
      if (!summaryFilterContent) return;
      const utils = getUtils();
      const allEmojiMap = utils.summaryEmojiMap || {};
      const faceEmojiMap = utils.summaryFaceEmojiMap || {};
      const emojiVisible = window.summaryEmojiVisible !== false;
      summaryFilterContent.innerHTML = "";

      const emojiToggleBtn = document.createElement("button");
      emojiToggleBtn.type = "button";
      emojiToggleBtn.className = "summaryFilterButton";
      emojiToggleBtn.classList.toggle("active", emojiVisible);
      emojiToggleBtn.textContent = emojiVisible ? t("Emojis: visible") : t("Emojis: hidden");
      emojiToggleBtn.addEventListener("click", () => {
        window.summaryEmojiVisible = !emojiVisible;
        applySummaryEmojiFilter();
        buildSummaryFilterUI();
      });
      summaryFilterContent.appendChild(emojiToggleBtn);

      // Color toggle
      const colorBtn = document.createElement("button");
      colorBtn.type = "button";
      colorBtn.className = "summaryFilterButton";
      const updateColorBtn = () => {
        colorBtn.classList.toggle("active", !window.summaryColorOff);
        colorBtn.textContent = window.summaryColorOff ? t("Text Color: default") : t("Text Color: colorful");
      };
      updateColorBtn();
      colorBtn.addEventListener("click", () => {
        window.summaryColorOff = !window.summaryColorOff;
        document.body?.classList.toggle("summary-color-off", window.summaryColorOff);
        updateColorBtn();
      });
      summaryFilterContent.appendChild(colorBtn);

      // Emoji filter buttons
      Object.keys(allEmojiMap).forEach((emoji) => {
        if (!(emoji in window.summaryEmojiFilter)) {
          window.summaryEmojiFilter[emoji] = true;
        }
      });
      Object.entries(faceEmojiMap).forEach(([emoji, data]) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "summaryFilterButton";
        const isOn = window.summaryEmojiFilter?.[emoji] !== false;
        btn.classList.toggle("active", isOn);

        btn.addEventListener("click", () => {
          const nowOn = !btn.classList.contains("active");
          btn.classList.toggle("active", nowOn);
          window.summaryEmojiFilter[emoji] = nowOn;
          applySummaryEmojiFilter();
        });

        const emojiSpan = document.createElement("span");
        emojiSpan.className = "summaryFilterEmoji";
        emojiSpan.textContent = emoji;
        if (data.color) emojiSpan.style.color = data.color;

        btn.appendChild(emojiSpan);
        summaryFilterContent.appendChild(btn);
      });
    }

    function buildEmojiLegendUI() {
      if (!emojiLegendContent) return;
      const utils = getUtils();
      const emojiMap = utils.summaryEmojiMap || {};
      const toDisplayName = (name) => {
        if (name === "Negative marker") return t("Negative marker");
        if (name === "King Cards") return t("King Cards");
        const localized = utils.translateGameText ? utils.translateGameText(name) : name;
        return localized;
      };

      emojiLegendContent.innerHTML = "";
      const title = document.createElement("div");
      title.className = "emojiLegendTitle";
      title.textContent = t("Emoji Legend");
      emojiLegendContent.appendChild(title);

      Object.entries(emojiMap).forEach(([emoji, data]) => {
        const row = document.createElement("div");
        row.className = "emojiLegendRow";

        const icon = document.createElement("span");
        icon.className = "emojiLegendIcon";
        icon.textContent = emoji;
        if (data?.color) icon.style.color = data.color;

        const text = document.createElement("span");
        text.className = "emojiLegendText";
        text.textContent = (data?.cards || []).map(toDisplayName).join(" / ");

        row.append(icon, text);
        emojiLegendContent.appendChild(row);
      });

      const packRow = document.createElement("div");
      packRow.className = "emojiLegendRow";
      const packIcon = document.createElement("span");
      packIcon.className = "emojiLegendIcon";
      packIcon.textContent = "ðŸ‘";
      const packText = document.createElement("span");
      packText.className = "emojiLegendText";
      packText.textContent = t("In packs marker");
      packRow.append(packIcon, packText);
      emojiLegendContent.appendChild(packRow);
    }

    // Emoji filter application - optimized version
    function applySummaryEmojiFilter() {
      const utils = getUtils();
      const emojiMap = utils.summaryEmojiMap || {};
      const faceEmojiMap = utils.summaryFaceEmojiMap || {};
      const filter = window.summaryEmojiFilter || {};
      const emojiVisible = window.summaryEmojiVisible !== false;
      const parseEmojis = (el) => {
        const raw = (el.dataset.summaryEmojis || "").trim();
        if (raw) {
          return raw.split(",").map((token) => token.trim()).filter(Boolean);
        }
        const face = (el.dataset.faceEmoji || "").trim();
        return face ? [face] : [];
      };
      const isFaceEntryVisible = (emoji) => !emoji || !(emoji in faceEmojiMap) || filter[emoji] !== false;

      const applyEmojiVisibilityToSegment = (el) => {
        const emojis = parseEmojis(el);
        const originalText = el.dataset.originalText ?? el.textContent ?? "";
        const hadNegative = originalText.includes("â€¼ï¸");
        if (!el.dataset.originalText) {
          el.dataset.originalText = originalText;
        }
        let nextText = originalText;
        if (!emojiVisible) {
          emojis.forEach((emoji) => {
            if (emoji in emojiMap && emoji !== "ðŸ‘") {
              nextText = nextText.split(emoji).join("");
            }
          });
        }
        nextText = nextText.replace(/\s{2,}/g, " ").trim();
        el.textContent = nextText;
        el.style.display = nextText ? "" : "none";

        if (el.classList.contains("summaryFaceSegment") || el.classList.contains("miniSummaryItem")) {
          const baseInfo = utils.getFaceInfoForSegment?.(originalText);
          if (hadNegative) {
            el.classList.add("negativeFace");
            el.style.color = "";
          } else {
            el.classList.remove("negativeFace");
            if (baseInfo?.color) {
              el.style.color = baseInfo.color;
            } else {
              el.style.color = "";
            }
          }
        }
      };

      document.querySelectorAll(".summaryText > span[data-summary-emojis], .summaryFaceSegment, .miniSummaryItem").forEach(applyEmojiVisibilityToSegment);

      // Per-icon filter (joker emoji icons) disables matching entries.
      document.querySelectorAll("[data-face-emoji]").forEach((el) => {
        const visible = isFaceEntryVisible(el.dataset.faceEmoji);
        if (el.classList.contains("summaryFaceSegment") || el.classList.contains("miniSummaryItem")) {
          if (!visible) el.style.display = "none";
        } else if (el.classList.contains("queueItem") || el.parentElement?.classList.contains("packItem")) {
          el.classList.toggle("emojiFilterOff", !visible);
        }
      });

      // Hide mini summary rows with no visible items (from per-icon filter only).
      document.querySelectorAll(".miniSummaryEntry").forEach((row) => {
        const items = row.querySelectorAll(".miniSummaryItem");
        row.style.display = !items.length || [...items].some((i) => i.style.display !== "none") ? "" : "none";
      });

      // Update delimiters in text containers
      const updateDelimiters = (container, delimClass) => {
        const children = [...container.children];
        const isPipe = (n) => n.classList.contains("summaryPipe") || n.classList.contains("miniSummaryPipe");
        const isContent = (n) => n?.nodeType === 1 && !n.classList.contains(delimClass) && !isPipe(n);
        const isVisibleContent = (n) => isContent(n) && n.style.display !== "none";

        children.forEach((node, idx) => {
          if (!node.classList?.contains(delimClass)) return;
          let prevVisible = false, hasAfter = false;
          for (let i = idx - 1; i >= 0 && !prevVisible; i--) if (isContent(children[i])) { prevVisible = isVisibleContent(children[i]); break; }
          for (let i = idx + 1; i < children.length && !hasAfter; i++) if (isVisibleContent(children[i])) { hasAfter = true; break; }
          node.style.display = prevVisible && hasAfter ? "" : "none";
        });
      };

      document.querySelectorAll(".summaryText").forEach((c) => updateDelimiters(c, "summaryDelimiter"));
      document.querySelectorAll(".miniSummaryText, .miniSummaryTextFull").forEach((c) => updateDelimiters(c, "miniSummaryDelimiter"));

      window.syncEmojiFilterToSearch?.();
    }

    window.applySummaryEmojiFilter = applySummaryEmojiFilter;

    // Summary toggle buttons
    summaryToggleButton.addEventListener("click", () => {
      setSummaryFloatingVisible(!summaryFloatingWindow.classList.contains("visible"));
    });

    summaryFilterToggle?.addEventListener("click", (e) => {
      e.stopPropagation();
      if (!summaryFilterWindow) return;
      const nowVisible = !summaryFilterWindow.classList.contains("visible");
      summaryFilterWindow.classList.toggle("visible", nowVisible);
      if (nowVisible) buildSummaryFilterUI();
    });

    summaryFilterWindow?.addEventListener("click", (e) => {
      e.stopPropagation();
    });

    emojiLegendButton?.addEventListener("click", (e) => {
      e.stopPropagation();
      if (!emojiLegendWindow) return;
      const nowVisible = !emojiLegendWindow.classList.contains("visible");
      emojiLegendWindow.classList.toggle("visible", nowVisible);
      if (nowVisible) buildEmojiLegendUI();
    });

    emojiLegendWindow?.addEventListener("click", (e) => {
      e.stopPropagation();
    });

    window.addEventListener("click", (e) => {
      if (summaryFilterWindow?.classList.contains("visible")) {
        if (!(e.target === summaryFilterWindow || summaryFilterWindow.contains(e.target) || e.target === summaryFilterToggle)) {
          summaryFilterWindow.classList.remove("visible");
        }
      }
      if (emojiLegendWindow?.classList.contains("visible")) {
        const localeContainer = document.getElementById("localeToggleContainer");
        if (!(e.target === emojiLegendWindow || emojiLegendWindow.contains(e.target) || localeContainer?.contains(e.target))) {
          emojiLegendWindow.classList.remove("visible");
        }
      }
    });

    // Balatro analysis loading
    let balatroAnalysisPromise = null;

    function ensureBalatroAnalysisLoaded() {
      if (window.BalatroAnalysis?.summarizeText) return Promise.resolve(window.BalatroAnalysis);
      if (!balatroAnalysisPromise) {
        balatroAnalysisPromise = new Promise((resolve, reject) => {
          const script = document.createElement("script");
          const version = window.__ASSET_VERSION__ || "1";
          script.src = `balatro_analysis.js?v=${version}`;
          script.onload = () => {
            window.BalatroAnalysis?.summarizeText ? resolve(window.BalatroAnalysis) : reject(new Error("BalatroAnalysis missing after load."));
          };
          script.onerror = () => reject(new Error("Failed to load balatro_analysis.js"));
          document.head.appendChild(script);
        });
      }
      return balatroAnalysisPromise;
    }

    function summarizeOutput(sourceButton) {
      const rawText = window.lastRawOutput || "";
      if (!rawText) {
        alert(t("Nothing to summarize yet."));
        return Promise.resolve();
      }

      if (summaryFloatingContent) summaryFloatingContent.textContent = t("Summarizing results...");

      const currentLocale = window.BalatroI18n?.getLocale?.() || window.__BALATRO_LOCALE__ || "zh-CN";
      const summaryOptions = String(currentLocale).toLowerCase() === "zh-cn" ? { chineseOnly: true } : {};

      if (sourceButton) setButtonLoadingState(sourceButton, true);
      if (summaryToggleButton) setButtonLoadingState(summaryToggleButton, true);

      return ensureBalatroAnalysisLoaded()
        .then((balatro) => {
          const anteMap = balatro.summarizeToAnteMap?.(rawText, summaryOptions);
          if (anteMap?.size) {
            window.lastSummariesByAnte = anteMap;
            window.lastSummary = Array.from(anteMap.values()).join("\n");
          } else {
            const summary = balatro.summarizeText(rawText, summaryOptions) || rawText;
            window.lastSummary = summary;
            window.lastSummariesByAnte = buildSummaryLookup(summary);
          }
          renderSummaryList();
          applySummaryEmojiFilter();
          window.refreshShopDisplay?.();
        })
        .catch((err) => {
          console.error("Failed to run balatro_analysis:", err);
          window.lastSummary = rawText;
          window.lastSummariesByAnte = buildSummaryLookup(rawText);
          renderSummaryList();
          applySummaryEmojiFilter();
          window.refreshShopDisplay?.();
        })
        .finally(() => {
          if (sourceButton) setButtonLoadingState(sourceButton, false);
          if (summaryToggleButton) setButtonLoadingState(summaryToggleButton, false);
        });
    }

    function copySummaryToClipboard() {
      if (!window.lastRawOutput?.trim()) {
        alert(t("Nothing to summarize yet."));
        return;
      }

      setButtonLoadingState(exportButton, true);
      const summaryReady = window.lastSummary?.trim()
        ? Promise.resolve()
        : summarizeOutput();

      summaryReady
        .then(() => {
          const summary = (window.lastSummary || "").trim();
          if (!summary) {
            alert(t("Nothing to summarize yet."));
            return;
          }
          return navigator.clipboard.writeText(summary).then(() => {
            alert(t("Summary copied to clipboard!"));
          });
        })
        .catch((err) => {
          console.error("Failed to copy summary:", err);
          alert(t("Failed to copy summary."));
        })
        .finally(() => {
          setButtonLoadingState(exportButton, false);
        });
    }

    exportButton.addEventListener("click", copySummaryToClipboard);
    analyzeButton.addEventListener("click", performAnalysis);

    // Immolate instance creation
    function createImmolateInstance(seed, deck, stake, version) {
      const inst = new Immolate.Instance(seed);
      inst.params = new Immolate.InstParams(deck, stake, false, version);
      inst.initLocks(1, false, false);
      ["Overstock Plus", "Liquidation", "Glow Up", "Reroll Glut", "Omen Globe", "Observatory",
       "Nacho Tong", "Recyclomancy", "Tarot Tycoon", "Planet Tycoon", "Money Tree",
       "Antimatter", "Illusion", "Petroglyph", "Retcon", "Palette"].forEach((v) => inst.lock(v));

      options.forEach((opt, i) => {
        if (!selectedOptions[i]) inst.lock(opt);
      });
      inst.setStake(stake);
      inst.setDeck(deck);
      return inst;
    }

    // Main analysis
    function clampAnteValue(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return 39;
      return Math.min(Math.max(Math.floor(numeric), 1), 39);
    }

    function performAnalysis() {
      const ante = clampAnteValue(anteInput.value);
      anteInput.value = String(ante);
      const cardsPerAnte = Array(ante).fill(Number(cardsPerAnteInput.value));
      const cardsPerAnteValue = Number(cardsPerAnteInput.value);
      const deck = deckSelect.value;
      const stake = stakeSelect.value;
      const version = parseInt(versionSelect.value);
      const seed = seedInput.value.toUpperCase().replace(/0/g, "O");

      let output = "";
      const outputChunks = [];
      const workload = ante * cardsPerAnteValue;
      setButtonLoadingState(analyzeButton, true);
      window.setGroupButtonsLoading?.(true);

      if (!Number.isFinite(ante) || ante < 1 || !Number.isFinite(cardsPerAnteValue) || cardsPerAnteValue < 0) {
        alert(t("Analyze failed. Check seed/version and try again."));
        setButtonLoadingState(analyzeButton, false);
        window.setGroupButtonsLoading?.(false);
        return;
      }

      // Prevent known wasm OOM scenarios on very large workloads.
      if (workload > 30000) {
        alert(t("Analyze workload is too large. Reduce Max Ante or Cards per Ante."));
        setButtonLoadingState(analyzeButton, false);
        window.setGroupButtonsLoading?.(false);
        return;
      }

      setTimeout(() => {
        let inst = null;
        let didFinalize = false;
        const finalizeAnalysis = () => {
          if (didFinalize) return;
          didFinalize = true;
          setButtonLoadingState(analyzeButton, false);
          window.setGroupButtonsLoading?.(false);
        };

        try {
          inst = createImmolateInstance(seed, deck, stake, version);
          const omitBeforeAnte9 = omitBeforeAnte9Checkbox.checked;

          for (let a = 1; a <= ante; a++) {
            inst.initUnlocks(a, false);
            const shouldOutput = !(omitBeforeAnte9 && a < 9);
            const addOutput = shouldOutput ? (t) => outputChunks.push(t) : () => {};

            addOutput(`==ANTE ${a}==\n`);
            addOutput(`Boss: ${inst.nextBoss(a)}\n`);
            const voucher = inst.nextVoucher(a);
            addOutput(`Voucher: ${voucher}\n`);
            inst.lock(voucher);

            // Unlock next level voucher
            for (let i = 0; i < Immolate.VOUCHERS.size(); i += 2) {
              if (Immolate.VOUCHERS.get(i) === voucher) {
                if (selectedOptions[options.indexOf(Immolate.VOUCHERS.get(i + 1))]) {
                  inst.unlock(Immolate.VOUCHERS.get(i + 1));
                }
              }
            }

            addOutput(`Tags: ${inst.nextTag(a)}, ${inst.nextTag(a)}\n`);
            addOutput("Shop Queue: \n");

            for (let q = 1; q <= cardsPerAnte[a - 1]; q++) {
              addOutput(`${q}) `);
              const item = inst.nextShopItem(a);
              if (item.type === "Joker") {
                if (item.jokerData.stickers.eternal) addOutput("Eternal ");
                if (item.jokerData.stickers.perishable) addOutput("Perishable ");
                if (item.jokerData.stickers.rental) addOutput("Rental ");
                if (item.jokerData.edition !== "No Edition") addOutput(`${item.jokerData.edition} `);
              }
              addOutput(`${item.item}\n`);
              item.delete();
            }

            addOutput("\nPacks: \n");
            const numPacks = a === 1 ? 4 : 6;
            for (let p = 1; p <= numPacks; p++) {
              const pack = inst.nextPack(a);
              addOutput(`${pack} - `);
              const packInfo = Immolate.packInfo(pack);

              if (packInfo.type === "Celestial Pack") {
                const cards = inst.nextCelestialPack(packInfo.size, a);
                for (let c = 0; c < packInfo.size; c++) {
                  addOutput(cards.get(c));
                  if (c + 1 !== packInfo.size) addOutput(", ");
                }
                cards.delete();
              }
              if (packInfo.type === "Arcana Pack") {
                const cards = inst.nextArcanaPack(packInfo.size, a);
                for (let c = 0; c < packInfo.size; c++) {
                  addOutput(cards.get(c));
                  if (c + 1 !== packInfo.size) addOutput(", ");
                }
                cards.delete();
              }
              if (packInfo.type === "Spectral Pack") {
                const cards = inst.nextSpectralPack(packInfo.size, a);
                for (let c = 0; c < packInfo.size; c++) {
                  addOutput(cards.get(c));
                  if (c + 1 !== packInfo.size) addOutput(", ");
                }
                cards.delete();
              }
              if (packInfo.type === "Buffoon Pack") {
                const cards = inst.nextBuffoonPack(packInfo.size, a);
                for (let c = 0; c < packInfo.size; c++) {
                  const joker = cards.get(c);
                  if (joker.stickers.eternal) addOutput("Eternal ");
                  if (joker.stickers.perishable) addOutput("Perishable ");
                  if (joker.stickers.rental) addOutput("Rental ");
                  if (joker.edition !== "No Edition") addOutput(`${joker.edition} `);
                  addOutput(joker.joker);
                  if (c + 1 !== packInfo.size) addOutput(", ");
                  joker.delete();
                }
                cards.delete();
              }
              if (packInfo.type === "Standard Pack") {
                const cards = inst.nextStandardPack(packInfo.size, a);
                for (let c = 0; c < packInfo.size; c++) {
                  const card = cards.get(c);
                  if (card.seal !== "No Seal") addOutput(`${card.seal} `);
                  if (card.edition !== "No Edition") addOutput(`${card.edition} `);
                  if (card.enhancement !== "No Enhancement") addOutput(`${card.enhancement} `);
                  const rank = card.base[2];
                  const rankName = { T: "10", J: "Jack", Q: "Queen", K: "King", A: "Ace" }[rank] || rank;
                  const suitName = { C: "Clubs", S: "Spades", D: "Diamonds", H: "Hearts" }[card.base[0]];
                  addOutput(`${rankName} of ${suitName}`);
                  if (c + 1 !== packInfo.size) addOutput(", ");
                  card.delete();
                }
                cards.delete();
              }
              addOutput("\n");
            }
            addOutput("\n");
          }

          output = outputChunks.join("");
          window.lastRawOutput = output;
          summarizeOutput().finally(() => {
            finalizeAnalysis();
            window.pendingScrollToResults = true;
            window.refreshShopDisplay?.() || document.getElementById("scrollingContainer")?.scrollIntoView({ behavior: "smooth", block: "start" });
          });
        } catch (err) {
          console.error("Analyze failed:", err);
          alert(t("Analyze failed. Check seed/version and try again."));
          finalizeAnalysis();
        } finally {
          if (inst) {
            try {
              inst.delete();
            } catch (_deleteErr) {
              // Ignore cleanup errors
            }
          }
        }
      }, 0);
    }

    // Single ante queue computation
    function computeSingleAnteQueue(targetAnte, cardsLimit) {
      const deck = deckSelect.value;
      const stake = stakeSelect.value;
      const version = parseInt(versionSelect.value);
      const seed = seedInput.value.toUpperCase().replace(/0/g, "O");
      const anteNum = Number(targetAnte);
      const limit = Math.max(0, Number(cardsLimit) || 0);

      if (!Number.isFinite(anteNum) || anteNum < 1 || !limit) return [];
      if (typeof Immolate === "undefined" || !Immolate.Instance) {
        console.error("Immolate wasm not ready for single-ante compute.");
        return [];
      }

      const inst = createImmolateInstance(seed, deck, stake, version);
      inst.initUnlocks(anteNum, false);

      const lines = [];
      for (let q = 1; q <= limit; q++) {
        const item = inst.nextShopItem(anteNum);
        let line = `${q}) `;
        if (item.type === "Joker" && item.jokerData) {
          if (item.jokerData.stickers.eternal) line += "Eternal ";
          if (item.jokerData.stickers.perishable) line += "Perishable ";
          if (item.jokerData.stickers.rental) line += "Rental ";
          if (item.jokerData.edition === "Negative") line += "â€¼ï¸ ";
          line += item.item;
        } else {
          line += item.item;
        }
        lines.push(line);
        item.delete();
      }

      inst.delete();
      return lines;
    }

    window.computeSingleAnteQueue = computeSingleAnteQueue;

    // URL parameter handling
    window.addEventListener("DOMContentLoaded", () => {
      const urlParams = new URLSearchParams(window.location.search);

      // Decode unlocks
      const urlUnlocks = urlParams.get("unlocks");
      if (urlUnlocks) {
        const binaryString = atob(urlUnlocks).split("").map((c) => c.charCodeAt(0).toString(2).padStart(8, "0")).join("");
        const paddingLength = binaryString.length % 8;
        const unpadded = paddingLength > 0 ? binaryString.slice(0, -paddingLength) : binaryString;
        selectedOptions = unpadded.split("").map((b) => b === "1");
      }

      // Apply URL parameters
      const urlAnte = urlParams.get("ante");
      const urlCardsPerAnte = urlParams.get("cardsPerAnte");
      const urlDeck = urlParams.get("deck");
      const urlStake = urlParams.get("stake");
      const urlSeed = urlParams.get("seed");
      const urlVersion = urlParams.get("version");
      const urlOmitBeforeAnte9 = urlParams.get("omitBeforeAnte9");

      if (urlAnte) {
        anteInput.value = clampAnteValue(urlAnte);
        cardsPerAnteInput.value = urlCardsPerAnte || "300";
      }
      if (urlCardsPerAnte) cardsPerAnteInput.value = urlCardsPerAnte;
      if (urlDeck) deckSelect.value = urlDeck;
      if (urlStake) stakeSelect.value = urlStake;
      if (urlVersion) versionSelect.value = urlVersion;
      if (urlOmitBeforeAnte9 !== null) omitBeforeAnte9Checkbox.checked = urlOmitBeforeAnte9 !== "false" && urlOmitBeforeAnte9 !== "0";

      if (urlSeed) {
        seedInput.value = filterSeed(urlSeed);
        window.instantAnalysis = true;
      }

      // Input validation
      seedInput.addEventListener("input", () => (seedInput.value = filterSeed(seedInput.value)));
      anteInput.addEventListener("input", () => (anteInput.value = clampAnteValue(anteInput.value)));
      cardsPerAnteInput.addEventListener("input", () => (cardsPerAnteInput.value = Math.min(Math.max(Number(cardsPerAnteInput.value), 0), 999)));

      function filterSeed(seed) {
        return seed.replace(/[^A-Za-z0-9]/g, "").toUpperCase().replace(/0/g, "O").slice(0, 8);
      }

      // Initial render
      applyUiLocalization();
      renderSummaryList();
      applySummaryEmojiFilter();
    });
  </script>
</html>
