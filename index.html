<!DOCTYPE html>
<html>
  <script>
    var Immolate = {
      onRuntimeInitialized: function () {
        if (window.instantAnalysis) {
          performAnalysis();
        }
      },
    };

    // Helper function for vectors
    function asVector(arr) {
      var vectorInt = new Module.VectorStr();
      for (var i = 0; i < arr.length; i++) {
        vectorInt.push_back(arr[i]);
      }
      return vectorInt;
    }
  </script>
  <script src="immolate.js"></script>
  <script src="balatro_lists.js"></script>
  <script src="UI.js" defer></script>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Soul</title>
    <link rel="stylesheet" href="base.css" />
    <link rel="stylesheet" href="ui.css" />
    <link rel="icon" type="image/png" href="images/icon.ico" />
  </head>
  <body>
    <h1 class="site-title">
      <img src="images/icon.ico" alt="The Soul icon" class="site-title-icon" width="48" height="48" />
      <span>The Soul</span>
    </h1>
    <div class="container">
      <div class="input-section">
        <h2>Settings</h2>

        <div class="settings-grid">
          <div class="settings-field">
            <label for="seed">Seed:</label>
            <input type="text" id="seed" maxlength="8" pattern="[A-Z1-9]{1,8}" class="settings-core-input" required />
          </div>

          <div class="settings-field">
            <label for="ante">Max Ante:</label>
            <input type="number" id="ante" min="1" max="999" class="settings-core-input" value="39" required />
          </div>

          <div class="settings-field">
            <label for="cardsPerAnte">Cards per Ante:</label>
            <input type="number" id="cardsPerAnte" min="0" max="999" value="300" class="settings-core-input" required />
          </div>

          <div class="settings-field">
            <label for="deck">Deck:</label>
            <select id="deck" required>
              <option value="Red Deck">Red Deck</option>
              <option value="Blue Deck">Blue Deck</option>
              <option value="Yellow Deck">Yellow Deck</option>
              <option value="Green Deck">Green Deck</option>
              <option value="Black Deck">Black Deck</option>
              <option value="Magic Deck">Magic Deck</option>
              <option value="Nebula Deck">Nebula Deck</option>
              <option value="Ghost Deck">Ghost Deck</option>
              <option value="Abandoned Deck">Abandoned Deck</option>
              <option value="Checkered Deck">Checkered Deck</option>
              <option value="Zodiac Deck">Zodiac Deck</option>
              <option value="Painted Deck">Painted Deck</option>
              <option value="Anaglyph Deck">Anaglyph Deck</option>
              <option value="Plasma Deck" selected>Plasma Deck</option>
              <option value="Erratic Deck">Erratic Deck</option>
            </select>
          </div>

          <div class="settings-field">
            <label for="stake">Stake:</label>
            <select id="stake" required>
              <option value="White Stake">White Stake</option>
              <option value="Red Stake">Red Stake</option>
              <option value="Green Stake">Green Stake</option>
              <option value="Black Stake">Black Stake</option>
              <option value="Blue Stake">Blue Stake</option>
              <option value="Purple Stake">Purple Stake</option>
              <option value="Orange Stake">Orange Stake</option>
              <option value="Gold Stake">Gold Stake</option>
            </select>
          </div>

          <div class="settings-field">
            <label for="version">Version:</label>
            <select id="version" required>
              <option value="10115">1.0.1o-full</option>
              <option value="10014">1.0.0n</option>
              <option value="10106">1.0.1f</option>
              <option value="10103">1.0.1c</option>
            </select>
          </div>
        </div>

        <div class="checkbox-row">
          <input type="checkbox" id="omitBeforeAnte9" checked />
          <label for="omitBeforeAnte9">Omit results before Ante 9</label>
        </div>

        <div class="settings-actions">
          <button id="analyzeButton">Analyze</button>
          <button id="openCheckboxesBtn">Modify Unlocks</button>
          <button id="copyButton">Copy Link</button>
          <button id="downloadButton">Download output</button>
          <button id="exportButton">Summarize</button>
          <div class="checkbox-row export-toggle">
            <input type="checkbox" id="withEnglishToggle" />
            <label for="withEnglishToggle">with English</label>
          </div>
        </div>

        <div id="checkboxesOverlay">
          <div id="checkboxesPopup">
            <h2>Unlocked Items</h2>
            <div id="checkboxesContainer" class="clearfix"></div>
            <button id="submitBtn">Submit</button>
            <button id="unlockBtn">Unlock All</button>
            <button id="lockBtn">Lock All</button>
          </div>
        </div>
      </div>
    </div>
    <div id="summaryFloatingWindow">
      <div id="summaryFloatingContent" aria-live="polite"></div>
    </div>
    <div id="summaryFilterWindow">
      <div id="summaryFilterContent"></div>
    </div>
    <div id="summaryButtons">
      <button id="summaryFloatingToggle" type="button">Summary</button>
      <button id="summaryFilterToggle" type="button">Filter</button>
    </div>
  </body>
  <script>
    // Unlocks configuration
    const options = [
      "Negative Tag", "Foil Tag", "Holographic Tag", "Polychrome Tag", "Rare Tag",
      "Golden Ticket", "Mr. Bones", "Acrobat", "Sock and Buskin", "Swashbuckler",
      "Troubadour", "Certificate", "Smeared Joker", "Throwback", "Hanging Chad",
      "Rough Gem", "Bloodstone", "Arrowhead", "Onyx Agate", "Glass Joker",
      "Showman", "Flower Pot", "Blueprint", "Wee Joker", "Merry Andy",
      "Oops! All 6s", "The Idol", "Seeing Double", "Matador", "Hit the Road",
      "The Duo", "The Trio", "The Family", "The Order", "The Tribe",
      "Stuntman", "Invisible Joker", "Brainstorm", "Satellite", "Shoot the Moon",
      "Driver's License", "Cartomancer", "Astronomer", "Burnt Joker", "Bootstraps",
      "Overstock Plus", "Liquidation", "Glow Up", "Reroll Glut", "Omen Globe",
      "Observatory", "Nacho Tong", "Recyclomancy", "Tarot Tycoon", "Planet Tycoon",
      "Money Tree", "Antimatter", "Illusion", "Petroglyph", "Retcon", "Palette",
    ];
    let selectedOptions = Array(61).fill(true);

    // DOM references
    const openCheckboxesBtn = document.getElementById("openCheckboxesBtn");
    const checkboxesOverlay = document.getElementById("checkboxesOverlay");
    const checkboxesContainer = document.getElementById("checkboxesContainer");
    const submitBtn = document.getElementById("submitBtn");
    const lockBtn = document.getElementById("lockBtn");
    const unlockBtn = document.getElementById("unlockBtn");

    // Checkbox management
    function createCheckboxes() {
      checkboxesContainer.innerHTML = "";
      const numColumns = 6;
      const optionsPerColumn = Math.ceil(options.length / numColumns);

      for (let i = 0; i < numColumns; i++) {
        const columnDiv = document.createElement("div");
        columnDiv.classList.add("checkbox-column");

        for (let j = i * optionsPerColumn; j < (i + 1) * optionsPerColumn && j < options.length; j++) {
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.value = options[j];
          checkbox.checked = selectedOptions[j];
          const label = document.createElement("label");
          label.textContent = options[j];
          label.prepend(checkbox);
          columnDiv.appendChild(label);
        }
        checkboxesContainer.appendChild(columnDiv);
      }
    }

    function handleSubmit() {
      const checkboxes = checkboxesContainer.querySelectorAll('input[type="checkbox"]');
      selectedOptions = Array.from(checkboxes).map((cb) => cb.checked);
      closeOverlay();
    }

    function handleLock() {
      checkboxesContainer.querySelectorAll('input[type="checkbox"]').forEach((cb) => (cb.checked = false));
    }

    function handleUnlock() {
      checkboxesContainer.querySelectorAll('input[type="checkbox"]').forEach((cb) => (cb.checked = true));
    }

    function openOverlay() {
      createCheckboxes();
      checkboxesOverlay.style.display = "block";
    }

    function closeOverlay() {
      checkboxesOverlay.style.display = "none";
    }

    openCheckboxesBtn.addEventListener("click", openOverlay);
    window.addEventListener("click", (e) => e.target === checkboxesOverlay && closeOverlay());
    submitBtn.addEventListener("click", handleSubmit);
    lockBtn.addEventListener("click", handleLock);
    unlockBtn.addEventListener("click", handleUnlock);

    // Initialize state
    window.instantAnalysis = false;
    window.lastRawOutput = "";
    window.lastSummary = "";
    window.lastSummariesByAnte = new Map();

    // DOM elements
    const anteInput = document.getElementById("ante");
    const cardsPerAnteInput = document.getElementById("cardsPerAnte");
    const deckSelect = document.getElementById("deck");
    const stakeSelect = document.getElementById("stake");
    const versionSelect = document.getElementById("version");
    const omitBeforeAnte9Checkbox = document.getElementById("omitBeforeAnte9");
    const seedInput = document.getElementById("seed");
    const analyzeButton = document.getElementById("analyzeButton");
    const copyLinkButton = document.getElementById("copyButton");
    const downloadButton = document.getElementById("downloadButton");
    const exportButton = document.getElementById("exportButton");
    const summaryToggleButton = document.getElementById("summaryFloatingToggle");
    const summaryFilterToggle = document.getElementById("summaryFilterToggle");
    const summaryFloatingWindow = document.getElementById("summaryFloatingWindow");
    const summaryFloatingContent = document.getElementById("summaryFloatingContent");
    const summaryFilterWindow = document.getElementById("summaryFilterWindow");
    const summaryFilterContent = document.getElementById("summaryFilterContent");
    const withEnglishToggle = document.getElementById("withEnglishToggle");

    // Helper to get utils (loaded later by UI.js)
    const getUtils = () => window.BalatroUtils || {};

    // Summary window visibility
    const setSummaryFloatingVisible = (flag) => {
      if (!summaryFloatingWindow) return;
      summaryFloatingWindow.classList.toggle("visible", Boolean(flag));
      document.body.classList.toggle("summary-floating-open", Boolean(flag));
    };

    // Button loading state (uses shared util when available)
    const setButtonLoadingState = (btn, flag) => {
      const utils = getUtils();
      if (utils.setButtonLoadingState) {
        utils.setButtonLoadingState(btn, flag);
      } else if (btn) {
        btn.disabled = Boolean(flag);
        btn.classList.toggle("is-loading", Boolean(flag));
      }
    };

    // Copy link functionality
    function copyLink() {
      const baseUrl = window.location.origin + window.location.pathname;
      const params = new URLSearchParams();

      // Encode unlocks as base64
      const binaryString = selectedOptions.map((u) => (u ? "1" : "0")).join("");
      const byteArray = [];
      for (let i = 0; i < binaryString.length; i += 8) {
        byteArray.push(parseInt(binaryString.substr(i, 8).padEnd(8, "0"), 2));
      }
      const base64Unlocks = btoa(String.fromCharCode.apply(null, byteArray));

      if (anteInput.value !== "39") params.append("ante", anteInput.value);
      if (cardsPerAnteInput.value !== "300") params.append("cardsPerAnte", cardsPerAnteInput.value);
      if (deckSelect.value !== "Plasma Deck") params.append("deck", deckSelect.value);
      if (stakeSelect.value !== "White Stake") params.append("stake", stakeSelect.value);
      if (versionSelect.value !== "10115") params.append("version", versionSelect.value);
      if (!omitBeforeAnte9Checkbox.checked) params.append("omitBeforeAnte9", "false");
      if (seedInput.value !== "") params.append("seed", seedInput.value);
      if (base64Unlocks !== "/////////x/4") params.append("unlocks", base64Unlocks);

      navigator.clipboard.writeText(`${baseUrl}?${params.toString()}`)
        .then(() => alert("Link copied to clipboard!"))
        .catch((err) => console.error("Failed to copy link:", err));
    }

    copyLinkButton.addEventListener("click", copyLink);

    // Download output
    downloadButton.addEventListener("click", () => {
      const content = window.lastRawOutput || "";
      if (!content) {
        alert("Nothing to download yet.");
        return;
      }
      const blob = new Blob([content], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = seedInput.value + "_analysis.txt";
      a.click();
      URL.revokeObjectURL(url);
    });

    // Summary rendering
    function buildSummaryLookup(summaryText) {
      const map = new Map();
      if (!summaryText?.trim()) return map;
      summaryText.split("\n").forEach((line) => {
        const trimmed = line.trim();
        if (!trimmed) return;
        const match = trimmed.match(/^ante\s*(\d+)\s*[：:]/i) || trimmed.match(/^(\d+)\s*[：:]/);
        if (match) {
          const anteNum = parseInt(match[1], 10);
          if (!Number.isNaN(anteNum) && !map.has(anteNum)) map.set(anteNum, trimmed);
        }
      });
      return map;
    }

    function renderSummaryList() {
      if (!summaryFloatingContent) return;
      const utils = getUtils();
      const map = window.lastSummariesByAnte;
      summaryFloatingContent.innerHTML = "";

      if (!map || map.size === 0) {
        const empty = document.createElement("div");
        empty.className = "summaryEmpty";
        empty.textContent = "Summary will appear here after you click Analyze.";
        summaryFloatingContent.appendChild(empty);
        return;
      }

      const items = [...map.entries()].sort((a, b) => a[0] - b[0]);
      items.forEach(([anteNum, rawLine], idx) => {
        const item = document.createElement("div");
        item.className = "summaryItem";
        item.dataset.ante = String(anteNum);
        item.dataset.order = String(idx);

        const anteLabel = document.createElement("button");
        anteLabel.type = "button";
        anteLabel.className = "summaryAnteButton";
        anteLabel.textContent = `Ante ${anteNum}`;

        const text = document.createElement("span");
        text.className = "summaryText";
        const cleaned = (utils.cleanSummaryLine || ((x) => x))(rawLine);
        const baseText = cleaned || rawLine;

        // Render segments with face coloring
        const segments = baseText.split(/(、|,)/);
        segments.forEach((seg) => {
          if (!seg) return;
          if (seg === "、" || seg === ",") {
            const delimSpan = document.createElement("span");
            delimSpan.className = "summaryDelimiter";
            delimSpan.textContent = seg;
            text.appendChild(delimSpan);
            if (seg === ",") text.appendChild(document.createTextNode(" "));
            return;
          }

          const chunks = seg.split(/(\|)/);
          chunks.forEach((chunk) => {
            if (!chunk) return;
            if (chunk === "|") {
              const pipeSpan = document.createElement("span");
              pipeSpan.className = "summaryPipe";
              pipeSpan.textContent = " | ";
              text.appendChild(pipeSpan);
              return;
            }

            const info = utils.getFaceInfoForSegment?.(chunk);
            const span = document.createElement("span");
            span.textContent = chunk;
            if (info) {
              span.className = "summaryFaceSegment";
              span.dataset.faceEmoji = info.emoji;
              if (chunk.includes("‼️")) {
                span.classList.add("negativeFace");
              } else if (info.color) {
                span.style.color = info.color;
              }
            }
            text.appendChild(span);
          });
        });

        // Reorder items on completion
        const reorderItems = () => {
          const parent = item.parentElement;
          if (!parent) return;
          const children = Array.from(parent.children);
          children.sort((a, b) => {
            const aCompleted = a.classList.contains("completed") ? 1 : 0;
            const bCompleted = b.classList.contains("completed") ? 1 : 0;
            if (aCompleted !== bCompleted) return aCompleted - bCompleted;
            return Number(a.dataset.order || 0) - Number(b.dataset.order || 0);
          });
          children.forEach((child) => parent.appendChild(child));
        };

        anteLabel.addEventListener("click", () => {
          if (typeof window.goToAntePage === "function") {
            window.goToAntePage(Number(item.dataset.ante || anteNum));
          }
          setSummaryFloatingVisible(false);

          requestAnimationFrame(() => {
            const container = document.getElementById("scrollingContainer");
            if (!container) return;
            const queueContainers = container.querySelectorAll(".queueContainer");
            let targetNode = null;
            queueContainers.forEach((qc) => {
              if (targetNode) return;
              const titleEl = qc.querySelector(".queueTitle.anteTitle");
              if (!titleEl) return;
              const match = titleEl.textContent?.match(/ANTE\s*(\d+)/i);
              if (match && Number(match[1]) === Number(item.dataset.ante)) targetNode = qc;
            });
            targetNode?.scrollIntoView({ behavior: "smooth", block: "start" });
          });
        });

        text.addEventListener("dblclick", () => {
          const nowCompleted = item.classList.toggle("completed");
          text.setAttribute("aria-pressed", nowCompleted ? "true" : "false");
          reorderItems();
        });

        item.append(anteLabel, text);
        summaryFloatingContent.appendChild(item);
      });
    }

    summaryFloatingContent.textContent = "Summary will appear here after you click Analyze.";

    // Summary filter UI
    function buildSummaryFilterUI() {
      if (!summaryFilterContent) return;
      const utils = getUtils();
      const emojiMap = utils.summaryFaceEmojiMap || {};
      summaryFilterContent.innerHTML = "";

      // Color toggle
      const colorBtn = document.createElement("button");
      colorBtn.type = "button";
      colorBtn.className = "summaryFilterButton";
      const updateColorBtn = () => {
        colorBtn.classList.toggle("active", window.summaryColorOff);
        colorBtn.textContent = window.summaryColorOff ? "Colors: default" : "Colors: emoji";
      };
      updateColorBtn();
      colorBtn.addEventListener("click", () => {
        window.summaryColorOff = !window.summaryColorOff;
        document.body?.classList.toggle("summary-color-off", window.summaryColorOff);
        updateColorBtn();
      });
      summaryFilterContent.appendChild(colorBtn);

      // Emoji filter buttons
      Object.entries(emojiMap).forEach(([emoji, data]) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "summaryFilterButton";
        const isOn = window.summaryEmojiFilter?.[emoji] !== false;
        btn.classList.toggle("active", isOn);

        btn.addEventListener("click", () => {
          const nowOn = !btn.classList.contains("active");
          btn.classList.toggle("active", nowOn);
          window.summaryEmojiFilter[emoji] = nowOn;
          applySummaryEmojiFilter();
        });

        const emojiSpan = document.createElement("span");
        emojiSpan.className = "summaryFilterEmoji";
        emojiSpan.textContent = emoji;
        if (data.color) emojiSpan.style.color = data.color;

        btn.appendChild(emojiSpan);
        summaryFilterContent.appendChild(btn);
      });
    }

    // Emoji filter application
    function applySummaryEmojiFilter() {
      const utils = getUtils();
      const emojiMap = utils.summaryFaceEmojiMap || {};
      const filter = window.summaryEmojiFilter || {};

      const isVisible = (emoji) => {
        if (!emoji || !Object.prototype.hasOwnProperty.call(emojiMap, emoji)) return true;
        return filter[emoji] !== false;
      };

      // Summary segments
      document.querySelectorAll(".summaryText .summaryFaceSegment").forEach((span) => {
        span.style.display = isVisible(span.dataset.faceEmoji || "") ? "" : "none";
      });

      // Mini summary items
      document.querySelectorAll(".miniSummaryItem").forEach((span) => {
        span.style.display = isVisible(span.dataset.faceEmoji || "") ? "" : "none";
      });

      // Queue/pack items
      document.querySelectorAll(".queueItem[data-face-emoji], .packItem > div[data-face-emoji]").forEach((el) => {
        el.classList.toggle("emojiFilterOff", !isVisible(el.dataset.faceEmoji || ""));
      });

      // Hide mini summary rows with no visible items
      document.querySelectorAll(".miniSummaryEntry").forEach((row) => {
        const items = row.querySelectorAll(".miniSummaryItem");
        if (!items.length) {
          row.style.display = "";
          return;
        }
        row.style.display = Array.from(items).some((i) => i.style.display !== "none") ? "" : "none";
      });

      // Hide redundant delimiters in summary
      document.querySelectorAll(".summaryText").forEach((container) => {
        const children = Array.from(container.children);
        const isVisibleSegment = (n) => n?.classList?.contains("summaryFaceSegment") && n.style.display !== "none";

        let first = -1, last = -1;
        children.forEach((node, idx) => {
          if (isVisibleSegment(node)) {
            if (first === -1) first = idx;
            last = idx;
          }
        });

        children.forEach((node, idx) => {
          if (!node.classList?.contains("summaryDelimiter")) return;
          node.style.display = (first === -1 || idx < first || idx > last) ? "none" : "";
        });
      });

      // Hide redundant delimiters in mini summaries
      document.querySelectorAll(".miniSummaryText").forEach((container) => {
        const children = Array.from(container.children);
        const isVisibleItem = (n) => n?.classList?.contains("miniSummaryItem") && n.style.display !== "none";

        let first = -1, last = -1;
        children.forEach((node, idx) => {
          if (isVisibleItem(node)) {
            if (first === -1) first = idx;
            last = idx;
          }
        });

        children.forEach((node, idx) => {
          if (!node.classList?.contains("miniSummaryDelimiter")) return;
          node.style.display = (first === -1 || idx < first || idx > last) ? "none" : "";
        });
      });

      // Sync to search filters
      if (window.syncEmojiFilterToSearch) window.syncEmojiFilterToSearch();
    }

    window.applySummaryEmojiFilter = applySummaryEmojiFilter;

    // Summary toggle buttons
    summaryToggleButton.addEventListener("click", () => {
      setSummaryFloatingVisible(!summaryFloatingWindow.classList.contains("visible"));
    });

    summaryFilterToggle?.addEventListener("click", (e) => {
      e.stopPropagation();
      if (!summaryFilterWindow) return;
      const nowVisible = !summaryFilterWindow.classList.contains("visible");
      summaryFilterWindow.classList.toggle("visible", nowVisible);
      if (nowVisible) buildSummaryFilterUI();
    });

    window.addEventListener("click", (e) => {
      if (!summaryFilterWindow?.classList.contains("visible")) return;
      if (e.target === summaryFilterWindow || summaryFilterWindow.contains(e.target) || e.target === summaryFilterToggle) return;
      summaryFilterWindow.classList.remove("visible");
    });

    // Balatro analysis loading
    let balatroAnalysisPromise = null;

    function ensureBalatroAnalysisLoaded() {
      if (window.BalatroAnalysis?.summarizeText) return Promise.resolve(window.BalatroAnalysis);
      if (!balatroAnalysisPromise) {
        balatroAnalysisPromise = new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.src = "balatro_analysis.js";
          script.onload = () => {
            window.BalatroAnalysis?.summarizeText ? resolve(window.BalatroAnalysis) : reject(new Error("BalatroAnalysis missing after load."));
          };
          script.onerror = () => reject(new Error("Failed to load balatro_analysis.js"));
          document.head.appendChild(script);
        });
      }
      return balatroAnalysisPromise;
    }

    function summarizeOutput(sourceButton) {
      const rawText = window.lastRawOutput || "";
      if (!rawText) {
        alert("Nothing to summarize yet.");
        return Promise.resolve();
      }

      if (summaryFloatingContent) summaryFloatingContent.textContent = "Summarizing results...";

      const withEnglish = withEnglishToggle?.checked ?? true;
      const summaryOptions = withEnglish ? {} : { chineseOnly: true };

      if (sourceButton) setButtonLoadingState(sourceButton, true);
      if (summaryToggleButton) setButtonLoadingState(summaryToggleButton, true);

      return ensureBalatroAnalysisLoaded()
        .then((balatro) => {
          const anteMap = balatro.summarizeToAnteMap?.(rawText, summaryOptions);
          if (anteMap?.size) {
            window.lastSummariesByAnte = anteMap;
            window.lastSummary = Array.from(anteMap.values()).join("\n");
          } else {
            const summary = balatro.summarizeText(rawText, summaryOptions) || rawText;
            window.lastSummary = summary;
            window.lastSummariesByAnte = buildSummaryLookup(summary);
          }
          renderSummaryList();
          applySummaryEmojiFilter();
          window.refreshShopDisplay?.();
        })
        .catch((err) => {
          console.error("Failed to run balatro_analysis:", err);
          window.lastSummary = rawText;
          window.lastSummariesByAnte = buildSummaryLookup(rawText);
          renderSummaryList();
          applySummaryEmojiFilter();
          window.refreshShopDisplay?.();
        })
        .finally(() => {
          if (sourceButton) setButtonLoadingState(sourceButton, false);
          if (summaryToggleButton) setButtonLoadingState(summaryToggleButton, false);
        });
    }

    exportButton.addEventListener("click", () => summarizeOutput(exportButton));
    analyzeButton.addEventListener("click", performAnalysis);

    // Immolate instance creation
    function createImmolateInstance(seed, deck, stake, version) {
      const inst = new Immolate.Instance(seed);
      inst.params = new Immolate.InstParams(deck, stake, false, version);
      inst.initLocks(1, false, false);
      ["Overstock Plus", "Liquidation", "Glow Up", "Reroll Glut", "Omen Globe", "Observatory",
       "Nacho Tong", "Recyclomancy", "Tarot Tycoon", "Planet Tycoon", "Money Tree",
       "Antimatter", "Illusion", "Petroglyph", "Retcon", "Palette"].forEach((v) => inst.lock(v));

      options.forEach((opt, i) => {
        if (!selectedOptions[i]) inst.lock(opt);
      });
      inst.setStake(stake);
      inst.setDeck(deck);
      return inst;
    }

    // Main analysis
    function performAnalysis() {
      const ante = parseInt(anteInput.value, 10);
      const cardsPerAnte = Array(ante).fill(Number(cardsPerAnteInput.value));
      const deck = deckSelect.value;
      const stake = stakeSelect.value;
      const version = parseInt(versionSelect.value);
      const seed = seedInput.value.toUpperCase().replace(/0/g, "O");

      let output = "";
      setButtonLoadingState(analyzeButton, true);
      window.setGroupButtonsLoading?.(true);

      setTimeout(() => {
        const inst = createImmolateInstance(seed, deck, stake, version);
        const omitBeforeAnte9 = omitBeforeAnte9Checkbox.checked;

        for (let a = 1; a <= ante; a++) {
          inst.initUnlocks(a, false);
          const shouldOutput = !(omitBeforeAnte9 && a < 9);
          const addOutput = shouldOutput ? (t) => (output += t) : () => {};

          addOutput(`==ANTE ${a}==\n`);
          addOutput(`Boss: ${inst.nextBoss(a)}\n`);
          const voucher = inst.nextVoucher(a);
          addOutput(`Voucher: ${voucher}\n`);
          inst.lock(voucher);

          // Unlock next level voucher
          for (let i = 0; i < Immolate.VOUCHERS.size(); i += 2) {
            if (Immolate.VOUCHERS.get(i) === voucher) {
              if (selectedOptions[options.indexOf(Immolate.VOUCHERS.get(i + 1))]) {
                inst.unlock(Immolate.VOUCHERS.get(i + 1));
              }
            }
          }

          addOutput(`Tags: ${inst.nextTag(a)}, ${inst.nextTag(a)}\n`);
          addOutput("Shop Queue: \n");

          for (let q = 1; q <= cardsPerAnte[a - 1]; q++) {
            addOutput(`${q}) `);
            const item = inst.nextShopItem(a);
            if (item.type === "Joker") {
              if (item.jokerData.stickers.eternal) addOutput("Eternal ");
              if (item.jokerData.stickers.perishable) addOutput("Perishable ");
              if (item.jokerData.stickers.rental) addOutput("Rental ");
              if (item.jokerData.edition !== "No Edition") addOutput(`${item.jokerData.edition} `);
            }
            addOutput(`${item.item}\n`);
            item.delete();
          }

          addOutput("\nPacks: \n");
          const numPacks = a === 1 ? 4 : 6;
          for (let p = 1; p <= numPacks; p++) {
            const pack = inst.nextPack(a);
            addOutput(`${pack} - `);
            const packInfo = Immolate.packInfo(pack);

            if (packInfo.type === "Celestial Pack") {
              const cards = inst.nextCelestialPack(packInfo.size, a);
              for (let c = 0; c < packInfo.size; c++) {
                addOutput(cards.get(c));
                if (c + 1 !== packInfo.size) addOutput(", ");
              }
              cards.delete();
            }
            if (packInfo.type === "Arcana Pack") {
              const cards = inst.nextArcanaPack(packInfo.size, a);
              for (let c = 0; c < packInfo.size; c++) {
                addOutput(cards.get(c));
                if (c + 1 !== packInfo.size) addOutput(", ");
              }
              cards.delete();
            }
            if (packInfo.type === "Spectral Pack") {
              const cards = inst.nextSpectralPack(packInfo.size, a);
              for (let c = 0; c < packInfo.size; c++) {
                addOutput(cards.get(c));
                if (c + 1 !== packInfo.size) addOutput(", ");
              }
              cards.delete();
            }
            if (packInfo.type === "Buffoon Pack") {
              const cards = inst.nextBuffoonPack(packInfo.size, a);
              for (let c = 0; c < packInfo.size; c++) {
                const joker = cards.get(c);
                if (joker.stickers.eternal) addOutput("Eternal ");
                if (joker.stickers.perishable) addOutput("Perishable ");
                if (joker.stickers.rental) addOutput("Rental ");
                if (joker.edition !== "No Edition") addOutput(`${joker.edition} `);
                addOutput(joker.joker);
                if (c + 1 !== packInfo.size) addOutput(", ");
                joker.delete();
              }
              cards.delete();
            }
            if (packInfo.type === "Standard Pack") {
              const cards = inst.nextStandardPack(packInfo.size, a);
              for (let c = 0; c < packInfo.size; c++) {
                const card = cards.get(c);
                if (card.seal !== "No Seal") addOutput(`${card.seal} `);
                if (card.edition !== "No Edition") addOutput(`${card.edition} `);
                if (card.enhancement !== "No Enhancement") addOutput(`${card.enhancement} `);
                const rank = card.base[2];
                const rankName = { T: "10", J: "Jack", Q: "Queen", K: "King", A: "Ace" }[rank] || rank;
                const suitName = { C: "Clubs", S: "Spades", D: "Diamonds", H: "Hearts" }[card.base[0]];
                addOutput(`${rankName} of ${suitName}`);
                if (c + 1 !== packInfo.size) addOutput(", ");
                card.delete();
              }
              cards.delete();
            }
            addOutput("\n");
          }
          addOutput("\n");
        }

        inst.delete();
        window.lastRawOutput = output;

        summarizeOutput().finally(() => {
          setButtonLoadingState(analyzeButton, false);
          window.setGroupButtonsLoading?.(false);
          window.pendingScrollToResults = true;
          window.refreshShopDisplay?.() || document.getElementById("scrollingContainer")?.scrollIntoView({ behavior: "smooth", block: "start" });
        });
      }, 0);
    }

    // Single ante queue computation
    function computeSingleAnteQueue(targetAnte, cardsLimit) {
      const deck = deckSelect.value;
      const stake = stakeSelect.value;
      const version = parseInt(versionSelect.value);
      const seed = seedInput.value.toUpperCase().replace(/0/g, "O");
      const anteNum = Number(targetAnte);
      const limit = Math.max(0, Number(cardsLimit) || 0);

      if (!Number.isFinite(anteNum) || anteNum < 1 || !limit) return [];
      if (typeof Immolate === "undefined" || !Immolate.Instance) {
        console.error("Immolate wasm not ready for single-ante compute.");
        return [];
      }

      const inst = createImmolateInstance(seed, deck, stake, version);
      inst.initUnlocks(anteNum, false);

      const lines = [];
      for (let q = 1; q <= limit; q++) {
        const item = inst.nextShopItem(anteNum);
        let line = `${q}) `;
        if (item.type === "Joker" && item.jokerData) {
          if (item.jokerData.stickers.eternal) line += "Eternal ";
          if (item.jokerData.stickers.perishable) line += "Perishable ";
          if (item.jokerData.stickers.rental) line += "Rental ";
          if (item.jokerData.edition === "Negative") line += "‼️ ";
          line += item.item;
        } else {
          line += item.item;
        }
        lines.push(line);
        item.delete();
      }

      inst.delete();
      return lines;
    }

    window.computeSingleAnteQueue = computeSingleAnteQueue;

    // URL parameter handling
    window.addEventListener("DOMContentLoaded", () => {
      const urlParams = new URLSearchParams(window.location.search);

      // Decode unlocks
      const urlUnlocks = urlParams.get("unlocks");
      if (urlUnlocks) {
        const binaryString = atob(urlUnlocks).split("").map((c) => c.charCodeAt(0).toString(2).padStart(8, "0")).join("");
        const paddingLength = binaryString.length % 8;
        const unpadded = paddingLength > 0 ? binaryString.slice(0, -paddingLength) : binaryString;
        selectedOptions = unpadded.split("").map((b) => b === "1");
      }

      // Apply URL parameters
      const urlAnte = urlParams.get("ante");
      const urlCardsPerAnte = urlParams.get("cardsPerAnte");
      const urlDeck = urlParams.get("deck");
      const urlStake = urlParams.get("stake");
      const urlSeed = urlParams.get("seed");
      const urlVersion = urlParams.get("version");
      const urlOmitBeforeAnte9 = urlParams.get("omitBeforeAnte9");

      if (urlAnte) {
        anteInput.value = Math.min(Math.max(Number(urlAnte), 1), 999);
        cardsPerAnteInput.value = urlCardsPerAnte || "300";
      }
      if (urlCardsPerAnte) cardsPerAnteInput.value = urlCardsPerAnte;
      if (urlDeck) deckSelect.value = urlDeck;
      if (urlStake) stakeSelect.value = urlStake;
      if (urlVersion) versionSelect.value = urlVersion;
      if (urlOmitBeforeAnte9 !== null) omitBeforeAnte9Checkbox.checked = urlOmitBeforeAnte9 !== "false" && urlOmitBeforeAnte9 !== "0";

      if (urlSeed) {
        seedInput.value = filterSeed(urlSeed);
        window.instantAnalysis = true;
      }

      // Input validation
      seedInput.addEventListener("input", () => (seedInput.value = filterSeed(seedInput.value)));
      anteInput.addEventListener("input", () => (anteInput.value = Math.min(Math.max(Number(anteInput.value), 1), 999)));
      cardsPerAnteInput.addEventListener("input", () => (cardsPerAnteInput.value = Math.min(Math.max(Number(cardsPerAnteInput.value), 0), 999)));

      function filterSeed(seed) {
        return seed.replace(/[^A-Za-z0-9]/g, "").toUpperCase().replace(/0/g, "O").slice(0, 8);
      }

      // Initial render
      renderSummaryList();
      applySummaryEmojiFilter();
    });
  </script>
</html>
