<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Soul</title>
    <link rel="preload" href="immolate.wasm" as="fetch" type="application/wasm" crossorigin="anonymous" />
    <link rel="stylesheet" href="base.css" />
    <link rel="stylesheet" href="ui.css" />
    <link rel="icon" type="image/png" href="images/icon.ico" />
    <script>
      (function initializeLocalePreference() {
        var fallbackLocale = "zh-CN";
        try {
          var saved = localStorage.getItem("balatro.locale");
          window.__BALATRO_LOCALE__ = (saved === "en-US" || saved === "zh-CN") ? saved : fallbackLocale;
        } catch (_err) {
          window.__BALATRO_LOCALE__ = fallbackLocale;
        }
      })();

      (function initializeUiUaMode() {
        var ua = navigator.userAgent || "";
        var isMobileUa = /Android|iPhone|iPad|iPod|Mobile|Windows Phone|HarmonyOS/i.test(ua);
        var supportsBackdrop = false;
        try {
          supportsBackdrop =
            !!(window.CSS &&
              CSS.supports &&
              (CSS.supports("backdrop-filter: blur(1px)") ||
                CSS.supports("-webkit-backdrop-filter: blur(1px)")));
        } catch (_err) {
          supportsBackdrop = false;
        }

        window.__UI_IS_MOBILE_UA__ = isMobileUa;
        window.__UI_SUPPORTS_BACKDROP__ = supportsBackdrop;

        var root = document.documentElement;
        if (!root) return;
        root.classList.add(isMobileUa ? "ua-mobile" : "ua-desktop");
        root.classList.add(isMobileUa || !supportsBackdrop ? "ua-no-blur" : "ua-blur");
      })();

      (function setAssetVersion() {
        var isLocal = /^(localhost|127\.0\.0\.1)$/.test(window.location.hostname);
        var version = isLocal ? String(Date.now()) : "1";
        window.__ASSET_VERSION__ = version;
      })();

      var Immolate = {
        onRuntimeInitialized: function () {
          if (window.instantAnalysis) {
            performAnalysis();
          }
        },
      };
    </script>
    <script src="immolate.js"></script>
    <script src="localization/generated/zh-CN.game.js"></script>
    <script src="localization/ui-zh-CN.js"></script>
    <script src="localization/i18n.global.js"></script>
    <script src="balatro_lists.js"></script>
    <script src="UI.js" defer></script>
  </head>
  <body>
    <h1 class="site-title">
      <div id="localeToggleContainer">
        <button id="localeToggleButton" type="button" aria-label="Toggle language">EN</button>
        <button id="emojiLegendButton" type="button" aria-label="Show intro">Intro</button>
      </div>
      <img src="images/icon.ico" alt="The Soul icon" class="site-title-icon" width="48" height="48" />
      <span>The Soul</span>
    </h1>
    <div class="container">
      <div class="input-section">
        <h2>Config Analyze</h2>

        <div class="settings-grid">
          <div class="settings-field">
            <label for="seed">Seed:</label>
            <input type="text" id="seed" maxlength="8" pattern="[A-Z1-9]{1,8}" class="settings-core-input" required />
          </div>

          <div class="settings-field">
            <label for="ante">Max Ante:</label>
            <input type="number" id="ante" min="1" max="39" class="settings-core-input" value="39" required />
          </div>

          <div class="settings-field">
            <label for="cardsPerAnte">Cards per Ante:</label>
            <input type="number" id="cardsPerAnte" min="0" max="999" value="300" class="settings-core-input" required />
          </div>

          <div class="settings-field">
            <label for="deck">Deck:</label>
            <select id="deck" required>
              <option value="Red Deck">Red Deck</option>
              <option value="Blue Deck">Blue Deck</option>
              <option value="Yellow Deck">Yellow Deck</option>
              <option value="Green Deck">Green Deck</option>
              <option value="Black Deck">Black Deck</option>
              <option value="Magic Deck">Magic Deck</option>
              <option value="Nebula Deck">Nebula Deck</option>
              <option value="Ghost Deck">Ghost Deck</option>
              <option value="Abandoned Deck">Abandoned Deck</option>
              <option value="Checkered Deck">Checkered Deck</option>
              <option value="Zodiac Deck">Zodiac Deck</option>
              <option value="Painted Deck">Painted Deck</option>
              <option value="Anaglyph Deck">Anaglyph Deck</option>
              <option value="Plasma Deck" selected>Plasma Deck</option>
              <option value="Erratic Deck">Erratic Deck</option>
            </select>
          </div>

          <div class="settings-field">
            <label for="stake">Stake:</label>
            <select id="stake" required>
              <option value="White Stake">White Stake</option>
              <option value="Red Stake">Red Stake</option>
              <option value="Green Stake">Green Stake</option>
              <option value="Black Stake">Black Stake</option>
              <option value="Blue Stake">Blue Stake</option>
              <option value="Purple Stake">Purple Stake</option>
              <option value="Orange Stake">Orange Stake</option>
              <option value="Gold Stake">Gold Stake</option>
            </select>
          </div>

          <div class="settings-field">
            <label for="version">Version:</label>
            <select id="version" required>
              <option value="10115">1.0.1o-full</option>
              <option value="10014">1.0.0n</option>
              <option value="10106">1.0.1f</option>
              <option value="10103">1.0.1c</option>
            </select>
          </div>
        </div>

        <div class="checkbox-row">
          <input type="checkbox" id="omitBeforeAnte9" checked />
          <label for="omitBeforeAnte9">Omit results before Ante 9</label>
        </div>
        <div class="settings-actions">
          <button id="analyzeButton">Analyze</button>
          <button id="openCheckboxesBtn">Modify Unlocks</button>
          <button id="copyButton">Copy Link</button>
          <button id="downloadButton">Download output</button>
          <button id="exportButton">Copy Summary</button>
        </div>

        <div id="checkboxesOverlay">
          <div id="checkboxesPopup">
            <h2>Unlocked Items</h2>
            <div id="checkboxesContainer"></div>
            <div class="unlock-actions">
              <button id="submitBtn">Submit</button>
              <button id="unlockBtn">Unlock All</button>
              <button id="lockBtn">Lock All</button>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="summaryFloatingWindow">
      <div id="summaryFloatingContent" aria-live="polite"></div>
    </div>
    <div id="summaryFilterWindow">
      <div id="summaryFilterContent"></div>
    </div>
    <div id="searchFloatingWindow"></div>
    <div id="emojiLegendWindow">
      <div id="emojiLegendContent"></div>
    </div>
    <div id="summaryButtons">
      <button id="searchFloatingToggle" type="button" aria-label="Search">üîç</button>
      <button id="summaryFloatingToggle" type="button">Summary</button>
      <button id="summaryFilterToggle" type="button">Settings</button>
    </div>
    <button id="scrollToTopButton" type="button" aria-label="Back to top">‚Üë</button>
  </body>
  <script>
    // Unlocks configuration
    const options = [
      "Negative Tag", "Foil Tag", "Holographic Tag", "Polychrome Tag", "Rare Tag",
      "Golden Ticket", "Mr. Bones", "Acrobat", "Sock and Buskin", "Swashbuckler",
      "Troubadour", "Certificate", "Smeared Joker", "Throwback", "Hanging Chad",
      "Rough Gem", "Bloodstone", "Arrowhead", "Onyx Agate", "Glass Joker",
      "Showman", "Flower Pot", "Blueprint", "Wee Joker", "Merry Andy",
      "Oops! All 6s", "The Idol", "Seeing Double", "Matador", "Hit the Road",
      "The Duo", "The Trio", "The Family", "The Order", "The Tribe",
      "Stuntman", "Invisible Joker", "Brainstorm", "Satellite", "Shoot the Moon",
      "Drivers License", "Cartomancer", "Astronomer", "Burnt Joker", "Bootstraps",
      "Overstock Plus", "Liquidation", "Glow Up", "Reroll Glut", "Omen Globe",
      "Observatory", "Nacho Tong", "Recyclomancy", "Tarot Tycoon", "Planet Tycoon",
      "Money Tree", "Antimatter", "Illusion", "Petroglyph", "Retcon", "Palette",
    ];
    let selectedOptions = Array(61).fill(true);

    // DOM references
    const openCheckboxesBtn = document.getElementById("openCheckboxesBtn");
    const checkboxesOverlay = document.getElementById("checkboxesOverlay");
    const checkboxesContainer = document.getElementById("checkboxesContainer");
    const submitBtn = document.getElementById("submitBtn");
    const lockBtn = document.getElementById("lockBtn");
    const unlockBtn = document.getElementById("unlockBtn");

    // Checkbox management
    function createCheckboxes() {
      checkboxesContainer.innerHTML = "";

      options.forEach((optionName, index) => {
        const row = document.createElement("div");
        row.className = "unlock-item";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = optionName;
        checkbox.checked = Boolean(selectedOptions[index]);
        checkbox.dataset.index = String(index);
        checkbox.id = `unlockOption_${index}`;

        const label = document.createElement("label");
        label.setAttribute("for", checkbox.id);
        label.textContent = t(optionName);

        row.append(checkbox, label);
        checkboxesContainer.appendChild(row);
      });
    }

    function handleSubmit() {
      const checkboxes = checkboxesContainer.querySelectorAll('input[type="checkbox"]');
      const next = Array(options.length).fill(false);
      checkboxes.forEach((checkbox) => {
        const idx = Number(checkbox.dataset.index);
        if (Number.isInteger(idx) && idx >= 0 && idx < next.length) {
          next[idx] = checkbox.checked;
        }
      });
      selectedOptions = next;
      closeOverlay();
    }

    function handleLock() {
      checkboxesContainer.querySelectorAll('input[type="checkbox"]').forEach((cb) => (cb.checked = false));
    }

    function handleUnlock() {
      checkboxesContainer.querySelectorAll('input[type="checkbox"]').forEach((cb) => (cb.checked = true));
    }

    function openOverlay() {
      createCheckboxes();
      checkboxesOverlay.style.display = "block";
    }

    function closeOverlay() {
      checkboxesOverlay.style.display = "none";
    }

    openCheckboxesBtn.addEventListener("click", openOverlay);
    submitBtn.addEventListener("click", handleSubmit);
    lockBtn.addEventListener("click", handleLock);
    unlockBtn.addEventListener("click", handleUnlock);

    // Initialize state
    window.instantAnalysis = false;
    window.lastRawOutput = "";
    window.lastSummary = "";
    window.lastSummariesByAnte = new Map();

    // DOM elements
    const anteInput = document.getElementById("ante");
    const cardsPerAnteInput = document.getElementById("cardsPerAnte");
    const deckSelect = document.getElementById("deck");
    const stakeSelect = document.getElementById("stake");
    const versionSelect = document.getElementById("version");
    const omitBeforeAnte9Checkbox = document.getElementById("omitBeforeAnte9");
    const seedInput = document.getElementById("seed");
    const analyzeButton = document.getElementById("analyzeButton");
    const copyLinkButton = document.getElementById("copyButton");
    const downloadButton = document.getElementById("downloadButton");
    const exportButton = document.getElementById("exportButton");
    const searchFloatingToggle = document.getElementById("searchFloatingToggle");
    const summaryToggleButton = document.getElementById("summaryFloatingToggle");
    const summaryFilterToggle = document.getElementById("summaryFilterToggle");
    const summaryFloatingWindow = document.getElementById("summaryFloatingWindow");
    const summaryFloatingContent = document.getElementById("summaryFloatingContent");
    const summaryFilterWindow = document.getElementById("summaryFilterWindow");
    const summaryFilterContent = document.getElementById("summaryFilterContent");
    const searchFloatingWindow = document.getElementById("searchFloatingWindow");
    const emojiLegendWindow = document.getElementById("emojiLegendWindow");
    const emojiLegendContent = document.getElementById("emojiLegendContent");
    const localeToggleButton = document.getElementById("localeToggleButton");
    const emojiLegendButton = document.getElementById("emojiLegendButton");
    const scrollToTopButton = document.getElementById("scrollToTopButton");

    // Helper to get utils (loaded later by UI.js)
    const getUtils = () => window.BalatroUtils || {};
    const t = (key) => window.BalatroI18n?.t ? window.BalatroI18n.t(key) : key;
    const isLocalHost = /^(localhost|127\.0\.0\.1)$/.test(window.location.hostname);

    function registerServiceWorker() {
      if (!("serviceWorker" in navigator)) return;
      if (!(window.isSecureContext || isLocalHost)) return;
      const swVersion = encodeURIComponent(window.__ASSET_VERSION__ || "1");
      window.addEventListener("load", () => {
        navigator.serviceWorker.register(`./sw.js?v=${swVersion}`).catch((err) => {
          console.warn("Service worker registration failed:", err);
        });
      }, { once: true });
    }
    registerServiceWorker();

    function applyUiLocalization() {
      const settingsHeader = document.querySelector(".input-section h2");
      if (settingsHeader) settingsHeader.textContent = t("Config Analyze");

      const setText = (selector, text) => {
        const el = document.querySelector(selector);
        if (el) el.textContent = text;
      };
      const localizeSelectOptions = (selectEl) => {
        if (!selectEl) return;
        Array.from(selectEl.options || []).forEach((option) => {
          option.textContent = t(option.value || option.textContent || "");
        });
      };

      setText('label[for="seed"]', t("Seed:"));
      setText('label[for="ante"]', t("Max Ante:"));
      setText('label[for="cardsPerAnte"]', t("Cards per Ante:"));
      setText('label[for="deck"]', t("Deck:"));
      setText('label[for="stake"]', t("Stake:"));
      setText('label[for="version"]', t("Version:"));
      setText('label[for="omitBeforeAnte9"]', t("Omit results before Ante 9"));

      if (analyzeButton) analyzeButton.textContent = t("Analyze");
      if (openCheckboxesBtn) openCheckboxesBtn.textContent = t("Modify Unlocks");
      if (copyLinkButton) copyLinkButton.textContent = t("Copy Link");
      if (downloadButton) downloadButton.textContent = t("Download output");
      if (exportButton) exportButton.textContent = t("Copy Summary");
      if (summaryToggleButton) summaryToggleButton.textContent = t("Summary");
      if (summaryFilterToggle) summaryFilterToggle.textContent = t("Settings");
      if (searchFloatingToggle) {
        searchFloatingToggle.textContent = "üîç";
        searchFloatingToggle.title = t("Search");
      }
      if (scrollToTopButton) {
        scrollToTopButton.textContent = "‚Üë";
        scrollToTopButton.title = t("Back to top");
        scrollToTopButton.setAttribute("aria-label", t("Back to top"));
      }

      setText("#checkboxesPopup h2", t("Unlocked Items"));
      if (submitBtn) submitBtn.textContent = t("Submit");
      if (unlockBtn) unlockBtn.textContent = t("Unlock All");
      if (lockBtn) lockBtn.textContent = t("Lock All");

      if (checkboxesOverlay && checkboxesOverlay.style.display === "block") {
        createCheckboxes();
      }

      localizeSelectOptions(deckSelect);
      localizeSelectOptions(stakeSelect);

      const localeNow = window.BalatroI18n?.getLocale?.() || window.__BALATRO_LOCALE__ || "zh-CN";
      if (localeToggleButton) {
        const switchToEnglish = localeNow === "zh-CN";
        localeToggleButton.textContent = switchToEnglish ? "EN" : "‰∏≠Êñá";
        localeToggleButton.title = switchToEnglish ? "Switch to English" : "ÂàáÊç¢Âà∞‰∏≠Êñá";
      }
      if (emojiLegendButton) {
        emojiLegendButton.textContent = t("Intro");
        emojiLegendButton.title = t("Intro");
      }
      if (emojiLegendWindow?.classList.contains("visible")) {
        if (emojiLegendWindow.classList.contains("visible")) {
          emojiLegendWindow.classList.remove("visible");
        }
        buildEmojiLegendUI();
      }
      if (summaryFilterWindow?.classList.contains("visible")) {
        buildSummaryFilterUI();
      }
    }

    // Summary window visibility
    const setSummaryFloatingVisible = (flag) => {
      if (!summaryFloatingWindow) return;
      const nextVisible = Boolean(flag);
      summaryFloatingWindow.classList.toggle("visible", nextVisible);
      document.body.classList.toggle("summary-floating-open", nextVisible);
      if (nextVisible && window.__RESET_SUMMARY_ON_NEXT_OPEN__) {
        resetSummaryFloatingScrollPosition();
        requestAnimationFrame(() => {
          resetSummaryFloatingScrollPosition();
          window.__RESET_SUMMARY_ON_NEXT_OPEN__ = false;
        });
      }
    };

    // Button loading state (uses shared util when available)
    const setButtonLoadingState = (btn, flag) => {
      const utils = getUtils();
      if (utils.setButtonLoadingState) {
        utils.setButtonLoadingState(btn, flag);
      } else if (btn) {
        btn.disabled = Boolean(flag);
        btn.classList.toggle("is-loading", Boolean(flag));
      }
    };

    const resetSummaryFloatingScrollPosition = () => {
      if (summaryFloatingContent) summaryFloatingContent.scrollTop = 0;
      if (summaryFloatingWindow) summaryFloatingWindow.scrollTop = 0;
    };

    window.__RESET_SUMMARY_ON_NEXT_OPEN__ = false;

    // Copy link functionality
    function copyLink() {
      const baseUrl = window.location.origin + window.location.pathname;
      const params = new URLSearchParams();

      // Encode unlocks as base64
      const binaryString = selectedOptions.map((u) => (u ? "1" : "0")).join("");
      const byteArray = [];
      for (let i = 0; i < binaryString.length; i += 8) {
        byteArray.push(parseInt(binaryString.substr(i, 8).padEnd(8, "0"), 2));
      }
      const base64Unlocks = btoa(String.fromCharCode.apply(null, byteArray));

      if (anteInput.value !== "39") params.append("ante", anteInput.value);
      if (cardsPerAnteInput.value !== "300") params.append("cardsPerAnte", cardsPerAnteInput.value);
      if (deckSelect.value !== "Plasma Deck") params.append("deck", deckSelect.value);
      if (stakeSelect.value !== "White Stake") params.append("stake", stakeSelect.value);
      if (versionSelect.value !== "10115") params.append("version", versionSelect.value);
      if (!omitBeforeAnte9Checkbox.checked) params.append("omitBeforeAnte9", "false");
      if (seedInput.value !== "") params.append("seed", seedInput.value);
      if (base64Unlocks !== "/////////x/4") params.append("unlocks", base64Unlocks);

      navigator.clipboard.writeText(`${baseUrl}?${params.toString()}`)
        .then(() => alert(t("Link copied to clipboard!")))
        .catch((err) => console.error("Failed to copy link:", err));
    }

    copyLinkButton.addEventListener("click", copyLink);

    // Locale toggle
    localeToggleButton?.addEventListener("click", () => {
      const localeNow = window.BalatroI18n?.getLocale?.() || window.__BALATRO_LOCALE__ || "zh-CN";
      const nextLocale = localeNow === "zh-CN" ? "en-US" : "zh-CN";
      try {
        localStorage.setItem("balatro.locale", nextLocale);
      } catch (_err) {
        // Ignore storage failures; reload still picks fallback.
      }
      window.__BALATRO_LOCALE__ = nextLocale;
      window.location.reload();
    });

    // Download output
    downloadButton.addEventListener("click", () => {
      const content = window.lastRawOutput || "";
      if (!content) {
        alert(t("Nothing to download yet."));
        return;
      }
      const blob = new Blob([content], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = seedInput.value + "_analysis.txt";
      a.click();
      URL.revokeObjectURL(url);
    });

    // Summary rendering
    function buildSummaryLookup(summaryText) {
      const map = new Map();
      if (!summaryText?.trim()) return map;
      summaryText.split("\n").forEach((line) => {
        const trimmed = line.trim();
        if (!trimmed) return;
        const match = trimmed.match(/^ante\s*(\d+)\s*[Ôºö:]/i) || trimmed.match(/^(\d+)\s*[Ôºö:]/);
        if (match) {
          const anteNum = parseInt(match[1], 10);
          if (!Number.isNaN(anteNum) && !map.has(anteNum)) map.set(anteNum, trimmed);
        }
      });
      return map;
    }

    function hasActiveTrackingItems() {
      const terms = window.BalatroSearch?.getActiveToggleTerms?.();
      if (terms && typeof terms.size === "number") return terms.size > 0;
      const appTrackingState = window.areTrackingTermsActive?.();
      if (typeof appTrackingState === "boolean") return appTrackingState;
      return true;
    }

    function renderSummaryEmpty(text) {
      if (!summaryFloatingContent) return;
      summaryFloatingContent.innerHTML = "";
      summaryFloatingContent.appendChild(Object.assign(document.createElement("div"), {
        className: "summaryEmpty",
        textContent: text,
      }));
    }

    function renderSummaryList() {
      if (!summaryFloatingContent) return;
      const utils = getUtils();
      const map = window.lastSummariesByAnte;
      summaryFloatingContent.innerHTML = "";

      if (!hasActiveTrackingItems()) {
        renderSummaryEmpty(t("No tracking items"));
        return;
      }

      if (!map?.size) {
        renderSummaryEmpty(t("Summary will appear here after you click Analyze."));
        return;
      }

      // Helper to render segments with delimiters and face coloring
      const renderSegments = (baseText, container) => {
        baseText.split(/(„ÄÅ|,)/).forEach((seg) => {
          if (!seg) return;
          if (seg === "„ÄÅ" || seg === ",") {
            container.appendChild(Object.assign(document.createElement("span"), { className: "summaryDelimiter", textContent: seg }));
            if (seg === ",") container.appendChild(document.createTextNode(" "));
            return;
          }
          seg.split(/(\|)/).forEach((chunk) => {
            if (!chunk) return;
            if (chunk === "|") { container.appendChild(Object.assign(document.createElement("span"), { className: "summaryPipe", textContent: " | " })); return; }
            const span = document.createElement("span");
            span.textContent = chunk;
            span.dataset.originalText = chunk;
            const info = utils.getFaceInfoForSegment?.(chunk);
            if (info) {
              span.className = "summaryFaceSegment";
              span.dataset.faceEmoji = info.emoji;
              chunk.includes("‚ÄºÔ∏è") ? span.classList.add("negativeFace") : info.color && (span.style.color = info.color);
            }
            const summaryEmojis = utils.getSummaryEmojisForText?.(chunk) || [];
            if (summaryEmojis.length) {
              span.dataset.summaryEmojis = summaryEmojis.join(",");
            }
            container.appendChild(span);
          });
        });
      };

      [...map.entries()].sort((a, b) => a[0] - b[0]).forEach(([anteNum, rawLine], idx) => {
        const item = Object.assign(document.createElement("div"), { className: "summaryItem" });
        item.dataset.ante = String(anteNum);
        item.dataset.order = String(idx);
        const cleanLine = (utils.cleanSummaryLine || ((x) => x))(rawLine) || rawLine;

        const anteLabel = Object.assign(document.createElement("button"), { type: "button", className: "summaryAnteButton", textContent: `Ante ${anteNum}` });
        const text = Object.assign(document.createElement("span"), { className: "summaryText" });
        renderSegments(cleanLine, text);

        anteLabel.addEventListener("click", () => {
          setSummaryFloatingVisible(false);
          window.goToAntePage?.(anteNum);
        });

        text.addEventListener("dblclick", () => {
          text.setAttribute("aria-pressed", item.classList.toggle("completed") ? "true" : "false");
          const parent = item.parentElement;
          if (parent) [...parent.children].sort((a, b) => (a.classList.contains("completed") ? 1 : 0) - (b.classList.contains("completed") ? 1 : 0) || (Number(a.dataset.order) || 0) - (Number(b.dataset.order) || 0)).forEach((c) => parent.appendChild(c));
        });

        item.append(anteLabel, text);
        summaryFloatingContent.appendChild(item);
      });
    }

    summaryFloatingContent.textContent = t("Summary will appear here after you click Analyze.");

    // Summary filter UI
    function buildSummaryFilterUI() {
      if (!summaryFilterContent) return;
      const utils = getUtils();
      const faceEmojiMap = utils.summaryFaceEmojiMap || {};
      const emojiVisible = window.summaryEmojiVisible !== false;
      summaryFilterContent.innerHTML = "";

      const emojiToggleBtn = document.createElement("button");
      emojiToggleBtn.type = "button";
      emojiToggleBtn.className = "summaryFilterButton";
      emojiToggleBtn.classList.toggle("active", emojiVisible);
      emojiToggleBtn.textContent = emojiVisible ? t("Emojis: visible") : t("Emojis: hidden");
      emojiToggleBtn.addEventListener("click", () => {
        window.summaryEmojiVisible = !emojiVisible;
        applySummaryEmojiFilter();
        buildSummaryFilterUI();
      });
      summaryFilterContent.appendChild(emojiToggleBtn);

      // Color toggle
      const colorBtn = document.createElement("button");
      colorBtn.type = "button";
      colorBtn.className = "summaryFilterButton";
      const updateColorBtn = () => {
        colorBtn.classList.toggle("active", !window.summaryColorOff);
        colorBtn.textContent = window.summaryColorOff ? t("Text Color: default") : t("Text Color: colorful");
      };
      updateColorBtn();
      colorBtn.addEventListener("click", () => {
        window.summaryColorOff = !window.summaryColorOff;
        document.body?.classList.toggle("summary-color-off", window.summaryColorOff);
        updateColorBtn();
      });
      summaryFilterContent.appendChild(colorBtn);

      const nearbyBtn = document.createElement("button");
      nearbyBtn.type = "button";
      nearbyBtn.className = "summaryFilterButton";
      const updateNearbyBtn = () => {
        const trackingActive = hasActiveTrackingItems();
        const visible = trackingActive && window.summaryNearbyVisible !== false;
        nearbyBtn.classList.toggle("active", visible);
        nearbyBtn.textContent = visible ? t("Nearby Summaries: visible") : t("Nearby Summaries: hidden");
        nearbyBtn.disabled = !trackingActive;
        nearbyBtn.title = !trackingActive ? t("No tracking items") : "";
      };
      updateNearbyBtn();
      nearbyBtn.addEventListener("click", () => {
        if (!hasActiveTrackingItems()) return;
        const nextVisible = window.summaryNearbyVisible === false;
        window.summaryNearbyVisible = nextVisible;
        window.setNearbySummariesVisible?.(nextVisible);
        updateNearbyBtn();
      });
      summaryFilterContent.appendChild(nearbyBtn);

      // Emoji filter buttons
      Object.keys(faceEmojiMap).forEach((emoji) => {
        if (!(emoji in window.summaryEmojiFilter)) {
          window.summaryEmojiFilter[emoji] = true;
        }
      });
      Object.entries(faceEmojiMap).forEach(([emoji, data]) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "summaryFilterButton";
        const isOn = window.summaryEmojiFilter?.[emoji] !== false;
        btn.classList.toggle("active", isOn);

        btn.addEventListener("click", () => {
          const nowOn = !btn.classList.contains("active");
          btn.classList.toggle("active", nowOn);
          window.summaryEmojiFilter[emoji] = nowOn;
          applySummaryEmojiFilter();
        });

        const emojiSpan = document.createElement("span");
        emojiSpan.className = "summaryFilterEmoji";
        emojiSpan.textContent = emoji;
        if (data.color) emojiSpan.style.color = data.color;

        btn.appendChild(emojiSpan);
        summaryFilterContent.appendChild(btn);
      });
    }

    function buildEmojiLegendUI() {
      if (!emojiLegendContent) return;
      const utils = getUtils();
      const emojiMap = utils.summaryFaceEmojiMap || {};
      const toDisplayName = (name) => {
        if (name === "Negative marker") return t("Negative marker");
        if (name === "King Cards") return t("King Cards");
        const localized = utils.translateGameText ? utils.translateGameText(name) : name;
        return localized;
      };

      const buildLegendTab = (container) => {
        Object.entries(emojiMap).forEach(([emoji, data]) => {
          const row = document.createElement("div");
          row.className = "emojiLegendRow";

          const icon = document.createElement("span");
          icon.className = "emojiLegendIcon";
          icon.textContent = emoji;
          if (data?.color) icon.style.color = data.color;

          const text = document.createElement("span");
          text.className = "emojiLegendText";
          text.textContent = (data?.cards || []).map(toDisplayName).join(" / ");

          row.append(icon, text);
          container.appendChild(row);
        });

        const packRow = document.createElement("div");
        packRow.className = "emojiLegendRow";
        const packIcon = document.createElement("span");
        packIcon.className = "emojiLegendIcon";
        packIcon.textContent = "üëù";
        const packText = document.createElement("span");
        packText.className = "emojiLegendText";
        packText.textContent = t("In packs marker");
        packRow.append(packIcon, packText);
        container.appendChild(packRow);
      };

      const buildTipsTab = (container) => {
        const tips = [
          t("Click Ante badge in Summary to jump to that Ante in main page."),
          t("Double-click a Summary row to mark it finished and move it to bottom; double-click again to restore."),
          t("In Nearby Summaries, text can scroll left/right; click an entry to open its popup detail."),
          t("In top-right Settings window, emoji icon buttons are Joker trackers."),
          t("These icon buttons sync with Search Filters > Jokers (same cards, two entry points)."),
          t("Search Filters: Select all / Remove all also toggles those Joker tracker icons."),
          t("Hit-only groups (‚óé / ‚óâ) are based on current highlights: search input + active Search Filters."),
        ];
        tips.forEach((tipText) => {
          const row = document.createElement("div");
          row.className = "introTipRow";
          const bullet = Object.assign(document.createElement("span"), { className: "introTipBullet", textContent: "‚Ä¢" });
          const text = Object.assign(document.createElement("span"), { className: "introTipText", textContent: tipText });
          row.append(bullet, text);
          container.appendChild(row);
        });

        const iconTitle = Object.assign(document.createElement("div"), {
          className: "emojiLegendTitle introSubTitle",
          textContent: t("Icon-only buttons"),
        });
        container.appendChild(iconTitle);

        const iconRows = [
          [["üîç"], t("Open search window")],
          [["‚ñ¶", "‚Üî"], t("Toggle card layout in each Ante (grid/carousel)")],
          [["‚óé", "‚óâ"], t("Toggle hit-only groups in each Ante")],
        ];
        iconRows.forEach(([icons, desc]) => {
          const row = document.createElement("div");
          row.className = "emojiLegendRow introIconRow";
          const icon = document.createElement("span");
          icon.className = `emojiLegendIcon introTextIcon${icons.length > 1 ? " introTextIconPair" : ""}`;
          if (icons.length > 1) {
            icons.forEach((iconText, idx) => {
              const glyph = Object.assign(document.createElement("span"), { className: "introPairGlyph", textContent: iconText });
              icon.appendChild(glyph);
              if (idx < icons.length - 1) {
                const sep = Object.assign(document.createElement("span"), { className: "introPairSep", textContent: "/" });
                sep.setAttribute("aria-hidden", "true");
                icon.appendChild(sep);
              }
            });
          } else {
            icon.textContent = icons[0] || "";
          }
          const text = Object.assign(document.createElement("span"), { className: "emojiLegendText", textContent: desc });
          row.append(icon, text);
          container.appendChild(row);
        });
      };

      emojiLegendContent.innerHTML = "";

      const tabs = document.createElement("div");
      tabs.className = "introTabs";
      const legendTabBtn = Object.assign(document.createElement("button"), { type: "button", className: "introTabButton", textContent: t("Emoji Legend") });
      const tipsTabBtn = Object.assign(document.createElement("button"), { type: "button", className: "introTabButton", textContent: t("UI Tips") });
      tabs.append(legendTabBtn, tipsTabBtn);
      emojiLegendContent.appendChild(tabs);

      const body = document.createElement("div");
      body.className = "introTabBody";
      emojiLegendContent.appendChild(body);

      const setTab = (tabName) => {
        const showLegend = tabName === "legend";
        legendTabBtn.classList.toggle("active", showLegend);
        tipsTabBtn.classList.toggle("active", !showLegend);
        body.innerHTML = "";
        if (showLegend) buildLegendTab(body);
        else buildTipsTab(body);
        window.__INTRO_ACTIVE_TAB__ = tabName;
      };

      legendTabBtn.addEventListener("click", () => setTab("legend"));
      tipsTabBtn.addEventListener("click", () => setTab("tips"));
      setTab(window.__INTRO_ACTIVE_TAB__ === "tips" ? "tips" : "legend");
    }

    // Emoji filter application - optimized version
    function applySummaryEmojiFilter() {
      const utils = getUtils();
      const emojiMap = utils.summaryEmojiMap || {};
      const faceEmojiMap = utils.summaryFaceEmojiMap || {};
      const faceCardMap = utils.summaryFaceCardMap || {};
      const filter = window.summaryEmojiFilter || {};
      const activeTerms = window.BalatroSearch?.getActiveToggleTerms?.() || null;
      const emojiVisible = window.summaryEmojiVisible !== false;
      const faceMatchCache = new Map();
      const faceMatchers = Object.entries(faceCardMap).map(([engName, info]) => ({
        engName,
        cnName: (info?.cn || "").trim(),
      }));
      const termTokenCache = new Map();
      const parseEmojis = (el) => {
        const raw = (el.dataset.summaryEmojis || "").trim();
        if (raw) {
          return raw.split(",").map((token) => token.trim()).filter(Boolean);
        }
        const face = (el.dataset.faceEmoji || "").trim();
        return face ? [face] : [];
      };
      const isFaceEntryVisible = (emoji) => !emoji || !(emoji in faceEmojiMap) || filter[emoji] !== false;
      const getMatchedFaceCards = (text) => {
        const source = String(text || "");
        if (!source) return [];
        if (faceMatchCache.has(source)) return faceMatchCache.get(source);
        const matches = [];
        faceMatchers.forEach(({ engName, cnName }) => {
          if (source.includes(engName) || (cnName && source.includes(cnName))) {
            matches.push(engName);
          }
        });
        faceMatchCache.set(source, matches);
        return matches;
      };
      const getTermTokens = (name) => {
        const key = String(name || "");
        if (!key) return [];
        if (termTokenCache.has(key)) return termTokenCache.get(key);
        const localized = utils.translateGameText ? utils.translateGameText(key) : key;
        const tokens = [key.toLowerCase()];
        if (localized) tokens.push(String(localized).toLowerCase());
        const deduped = [...new Set(tokens.filter(Boolean))];
        termTokenCache.set(key, deduped);
        return deduped;
      };
      const getMatchedMappedCards = (text, emojis) => {
        const source = String(text || "").toLowerCase();
        if (!source || !Array.isArray(emojis) || !emojis.length) return [];
        const matches = new Set();
        emojis.forEach((emoji) => {
          const cards = emojiMap?.[emoji]?.cards || [];
          cards.forEach((cardName) => {
            const tokens = getTermTokens(cardName);
            if (tokens.some((token) => source.includes(token))) {
              matches.add(cardName);
            }
          });
        });
        return [...matches];
      };
      const isSegmentTermVisible = (el, emojis) => {
        if (!activeTerms || typeof activeTerms.has !== "function") return true;
        const source = el.dataset.originalText ?? el.textContent ?? "";
        const matchedCards = [
          ...getMatchedFaceCards(source),
          ...getMatchedMappedCards(source, emojis),
        ];
        if (!matchedCards.length) return true;
        return matchedCards.some((name) => activeTerms.has(String(name).toLowerCase()));
      };

      const applyEmojiVisibilityToSegment = (el) => {
        const emojis = parseEmojis(el);
        const originalText = el.dataset.originalText ?? el.textContent ?? "";
        const hadNegative = originalText.includes("‚ÄºÔ∏è");
        if (!el.dataset.originalText) {
          el.dataset.originalText = originalText;
        }
        let nextText = originalText;
        if (!emojiVisible) {
          emojis.forEach((emoji) => {
            if (emoji in emojiMap && emoji !== "üëù") {
              nextText = nextText.split(emoji).join("");
            }
          });
        }
        nextText = nextText.replace(/\s{2,}/g, " ").trim();
        el.textContent = nextText;
        el.style.display = nextText ? "" : "none";

        if (el.classList.contains("summaryFaceSegment") || el.classList.contains("miniSummaryItem")) {
          const baseInfo = utils.getFaceInfoForSegment?.(originalText);
          if (hadNegative) {
            el.classList.add("negativeFace");
            el.style.color = "";
          } else {
            el.classList.remove("negativeFace");
            if (baseInfo?.color) {
              el.style.color = baseInfo.color;
            } else {
              el.style.color = "";
            }
          }
        }
      };

      document.querySelectorAll(".summaryText > span[data-summary-emojis], .summaryFaceSegment, .miniSummaryItem").forEach(applyEmojiVisibilityToSegment);

      // Per-icon filter (joker emoji icons) + active search filters control summary visibility.
      document.querySelectorAll(".summaryText > span[data-summary-emojis], .summaryFaceSegment, .miniSummaryItem").forEach((el) => {
        const emojis = parseEmojis(el);
        const visibleByEmoji = !emojis.length || emojis.every((emoji) => isFaceEntryVisible(emoji));
        const visibleByTerms = isSegmentTermVisible(el, emojis);
        if (!visibleByEmoji || !visibleByTerms) {
          el.style.display = "none";
        }
      });

      // Hide mini summary rows with no visible items (from per-icon filter only).
      document.querySelectorAll(".miniSummaryEntry").forEach((row) => {
        const items = row.querySelectorAll(".miniSummaryItem");
        row.style.display = !items.length || [...items].some((i) => i.style.display !== "none") ? "" : "none";
      });

      // Update delimiters in text containers
      const updateDelimiters = (container, delimClass, pipeClass) => {
        const children = [...container.children];
        const isPipe = (n) => n?.classList?.contains(pipeClass);
        const isDelimiter = (n) => n?.classList?.contains(delimClass) || isPipe(n);
        const isContent = (n) => n?.nodeType === 1 && !isDelimiter(n);
        const isVisibleContent = (n) => isContent(n) && n.style.display !== "none";

        children.forEach((node, idx) => {
          if (!isDelimiter(node)) return;
          let prevVisible = false, hasAfter = false;
          for (let i = idx - 1; i >= 0 && !prevVisible; i--) if (isContent(children[i])) { prevVisible = isVisibleContent(children[i]); break; }
          for (let i = idx + 1; i < children.length && !hasAfter; i++) if (isVisibleContent(children[i])) { hasAfter = true; break; }
          node.style.display = prevVisible && hasAfter ? "" : "none";
        });
      };

      document.querySelectorAll(".summaryText").forEach((c) => updateDelimiters(c, "summaryDelimiter", "summaryPipe"));
      document.querySelectorAll(".miniSummaryText, .miniSummaryTextFull").forEach((c) => updateDelimiters(c, "miniSummaryDelimiter", "miniSummaryPipe"));

      const syncChanged = window.syncEmojiFilterToSearch?.();
      if (syncChanged) {
        requestAnimationFrame(() => {
          window.syncEmojiFilterToSearch?.();
          window.applySummaryEmojiFilter?.();
        });
      }
    }

    window.applySummaryEmojiFilter = applySummaryEmojiFilter;
    window.onTrackingTermsStateChange = () => {
      renderSummaryList();
      if (hasActiveTrackingItems()) {
        applySummaryEmojiFilter();
      }
      if (summaryFilterWindow?.classList.contains("visible")) {
        buildSummaryFilterUI();
      }
    };

    function closeOtherFloatingWindows(exceptWindow) {
      if (summaryFloatingWindow && summaryFloatingWindow !== exceptWindow) {
        setSummaryFloatingVisible(false);
      }
      [summaryFilterWindow, searchFloatingWindow, emojiLegendWindow].forEach((win) => {
        if (win && win !== exceptWindow) win.classList.remove("visible");
      });
    }

    // Summary toggle buttons
    summaryToggleButton.addEventListener("click", (e) => {
      e.stopPropagation();
      const nowVisible = !summaryFloatingWindow.classList.contains("visible");
      if (nowVisible) closeOtherFloatingWindows(summaryFloatingWindow);
      setSummaryFloatingVisible(nowVisible);
    });

    summaryFilterToggle?.addEventListener("click", (e) => {
      e.stopPropagation();
      if (!summaryFilterWindow) return;
      const nowVisible = !summaryFilterWindow.classList.contains("visible");
      if (nowVisible) closeOtherFloatingWindows(summaryFilterWindow);
      summaryFilterWindow.classList.toggle("visible", nowVisible);
      if (nowVisible) buildSummaryFilterUI();
    });

    summaryFilterWindow?.addEventListener("click", (e) => {
      e.stopPropagation();
    });

    searchFloatingToggle?.addEventListener("click", (e) => {
      e.stopPropagation();
      if (!searchFloatingWindow) return;
      const nowVisible = !searchFloatingWindow.classList.contains("visible");
      if (nowVisible) closeOtherFloatingWindows(searchFloatingWindow);
      searchFloatingWindow.classList.toggle("visible", nowVisible);
    });

    searchFloatingWindow?.addEventListener("click", (e) => {
      e.stopPropagation();
    });

    emojiLegendButton?.addEventListener("click", (e) => {
      e.stopPropagation();
      if (!emojiLegendWindow) return;
      const nowVisible = !emojiLegendWindow.classList.contains("visible");
      if (nowVisible) closeOtherFloatingWindows(emojiLegendWindow);
      emojiLegendWindow.classList.toggle("visible", nowVisible);
      if (nowVisible) buildEmojiLegendUI();
    });

    emojiLegendWindow?.addEventListener("click", (e) => {
      e.stopPropagation();
    });

    function closeFloatingWindows() {
      let closedAny = false;
      if (summaryFloatingWindow?.classList.contains("visible")) {
        setSummaryFloatingVisible(false);
        closedAny = true;
      }
      if (summaryFilterWindow?.classList.contains("visible")) {
        summaryFilterWindow.classList.remove("visible");
        closedAny = true;
      }
      if (searchFloatingWindow?.classList.contains("visible")) {
        searchFloatingWindow.classList.remove("visible");
        closedAny = true;
      }
      if (emojiLegendWindow?.classList.contains("visible")) {
        emojiLegendWindow.classList.remove("visible");
        closedAny = true;
      }
      if (checkboxesOverlay?.style.display === "block") {
        closeOverlay();
        closedAny = true;
      }
      return closedAny;
    }

    function updateScrollToTopButton() {
      if (!scrollToTopButton) return;
      const visible = window.scrollY > 320;
      scrollToTopButton.classList.toggle("visible", visible);
    }

    scrollToTopButton?.addEventListener("click", () => {
      window.scrollTo({ top: 0, behavior: "smooth" });
    });
    window.addEventListener("scroll", updateScrollToTopButton, { passive: true });
    updateScrollToTopButton();

    window.addEventListener("keydown", (e) => {
      if (e.key !== "Escape") return;
      if (closeFloatingWindows()) {
        e.preventDefault();
        e.stopPropagation();
      }
    });

    window.addEventListener("click", (e) => {
      if (e.target === checkboxesOverlay) {
        closeOverlay();
      }
      if (summaryFloatingWindow?.classList.contains("visible")) {
        if (!(e.target === summaryFloatingWindow || summaryFloatingWindow.contains(e.target) || e.target === summaryToggleButton)) {
          setSummaryFloatingVisible(false);
        }
      }
      if (summaryFilterWindow?.classList.contains("visible")) {
        if (!(e.target === summaryFilterWindow || summaryFilterWindow.contains(e.target) || e.target === summaryFilterToggle)) {
          summaryFilterWindow.classList.remove("visible");
        }
      }
      if (searchFloatingWindow?.classList.contains("visible")) {
        if (!(e.target === searchFloatingWindow || searchFloatingWindow.contains(e.target) || e.target === searchFloatingToggle)) {
          searchFloatingWindow.classList.remove("visible");
        }
      }
      if (emojiLegendWindow?.classList.contains("visible")) {
        const localeContainer = document.getElementById("localeToggleContainer");
        if (!(e.target === emojiLegendWindow || emojiLegendWindow.contains(e.target) || localeContainer?.contains(e.target))) {
          emojiLegendWindow.classList.remove("visible");
        }
      }
    });

    // Balatro analysis loading
    let balatroAnalysisPromise = null;

    function ensureBalatroAnalysisLoaded() {
      if (window.BalatroAnalysis?.summarizeText) return Promise.resolve(window.BalatroAnalysis);
      if (!balatroAnalysisPromise) {
        balatroAnalysisPromise = new Promise((resolve, reject) => {
          const script = document.createElement("script");
          const version = window.__ASSET_VERSION__ || "1";
          script.src = `balatro_analysis.js?v=${version}`;
          script.onload = () => {
            window.BalatroAnalysis?.summarizeText ? resolve(window.BalatroAnalysis) : reject(new Error("BalatroAnalysis missing after load."));
          };
          script.onerror = () => reject(new Error("Failed to load balatro_analysis.js"));
          document.head.appendChild(script);
        });
      }
      return balatroAnalysisPromise;
    }

    function summarizeOutput(sourceButton) {
      const rawText = window.lastRawOutput || "";
      if (!rawText) {
        alert(t("Nothing to summarize yet."));
        return Promise.resolve();
      }

      if (summaryFloatingContent) summaryFloatingContent.textContent = t("Summarizing results...");

      const currentLocale = window.BalatroI18n?.getLocale?.() || window.__BALATRO_LOCALE__ || "zh-CN";
      const summaryOptions = String(currentLocale).toLowerCase() === "zh-cn" ? { chineseOnly: true } : {};

      if (sourceButton) setButtonLoadingState(sourceButton, true);
      if (summaryToggleButton) setButtonLoadingState(summaryToggleButton, true);

      return ensureBalatroAnalysisLoaded()
        .then((balatro) => {
          const anteMap = balatro.summarizeToAnteMap?.(rawText, summaryOptions);
          if (anteMap?.size) {
            window.lastSummariesByAnte = anteMap;
            window.lastSummary = Array.from(anteMap.values()).join("\n");
          } else {
            const summary = balatro.summarizeText(rawText, summaryOptions) || rawText;
            window.lastSummary = summary;
            window.lastSummariesByAnte = buildSummaryLookup(summary);
          }
          renderSummaryList();
          resetSummaryFloatingScrollPosition();
          applySummaryEmojiFilter();
          window.refreshShopDisplay?.();
        })
        .catch((err) => {
          console.error("Failed to run balatro_analysis:", err);
          window.lastSummary = rawText;
          window.lastSummariesByAnte = buildSummaryLookup(rawText);
          renderSummaryList();
          resetSummaryFloatingScrollPosition();
          applySummaryEmojiFilter();
          window.refreshShopDisplay?.();
        })
        .finally(() => {
          if (sourceButton) setButtonLoadingState(sourceButton, false);
          if (summaryToggleButton) setButtonLoadingState(summaryToggleButton, false);
        });
    }

    function copySummaryToClipboard() {
      if (!window.lastRawOutput?.trim()) {
        alert(t("Nothing to summarize yet."));
        return;
      }

      setButtonLoadingState(exportButton, true);
      const summaryReady = window.lastSummary?.trim()
        ? Promise.resolve()
        : summarizeOutput();

      summaryReady
        .then(() => {
          const summary = (window.lastSummary || "").trim();
          if (!summary) {
            alert(t("Nothing to summarize yet."));
            return;
          }
          return navigator.clipboard.writeText(summary).then(() => {
            alert(t("Summary copied to clipboard!"));
          });
        })
        .catch((err) => {
          console.error("Failed to copy summary:", err);
          alert(t("Failed to copy summary."));
        })
        .finally(() => {
          setButtonLoadingState(exportButton, false);
        });
    }

    exportButton.addEventListener("click", copySummaryToClipboard);
    analyzeButton.addEventListener("click", performAnalysis);

    // Immolate instance creation
    function createImmolateInstance(seed, deck, stake, version) {
      const inst = new Immolate.Instance(seed);
      inst.params = new Immolate.InstParams(deck, stake, false, version);
      inst.initLocks(1, false, false);
      ["Overstock Plus", "Liquidation", "Glow Up", "Reroll Glut", "Omen Globe", "Observatory",
       "Nacho Tong", "Recyclomancy", "Tarot Tycoon", "Planet Tycoon", "Money Tree",
       "Antimatter", "Illusion", "Petroglyph", "Retcon", "Palette"].forEach((v) => inst.lock(v));

      options.forEach((opt, i) => {
        if (!selectedOptions[i]) inst.lock(opt);
      });
      inst.setStake(stake);
      inst.setDeck(deck);
      return inst;
    }

    // Main analysis
    function clampAnteValue(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return 39;
      return Math.min(Math.max(Math.floor(numeric), 1), 39);
    }

    function performAnalysis() {
      const ante = clampAnteValue(anteInput.value);
      anteInput.value = String(ante);
      const cardsPerAnte = Array(ante).fill(Number(cardsPerAnteInput.value));
      const cardsPerAnteValue = Number(cardsPerAnteInput.value);
      const deck = deckSelect.value;
      const stake = stakeSelect.value;
      const version = parseInt(versionSelect.value);
      const seed = seedInput.value.toUpperCase().replace(/0/g, "O");

      let output = "";
      const outputChunks = [];
      const workload = ante * cardsPerAnteValue;
      setButtonLoadingState(analyzeButton, true);
      window.setGroupButtonsLoading?.(true);
      window.__RESET_SUMMARY_ON_NEXT_OPEN__ = true;
      resetSummaryFloatingScrollPosition();

      if (!Number.isFinite(ante) || ante < 1 || !Number.isFinite(cardsPerAnteValue) || cardsPerAnteValue < 0) {
        alert(t("Analyze failed. Check seed/version and try again."));
        setButtonLoadingState(analyzeButton, false);
        window.setGroupButtonsLoading?.(false);
        return;
      }

      // Prevent known wasm OOM scenarios on very large workloads.
      if (workload > 30000) {
        alert(t("Analyze workload is too large. Reduce Max Ante or Cards per Ante."));
        setButtonLoadingState(analyzeButton, false);
        window.setGroupButtonsLoading?.(false);
        return;
      }

      setTimeout(() => {
        let inst = null;
        let didFinalize = false;
        const finalizeAnalysis = () => {
          if (didFinalize) return;
          didFinalize = true;
          setButtonLoadingState(analyzeButton, false);
          window.setGroupButtonsLoading?.(false);
        };

        try {
          inst = createImmolateInstance(seed, deck, stake, version);
          const omitBeforeAnte9 = omitBeforeAnte9Checkbox.checked;

          for (let a = 1; a <= ante; a++) {
            inst.initUnlocks(a, false);
            const shouldOutput = !(omitBeforeAnte9 && a < 9);
            const addOutput = shouldOutput ? (t) => outputChunks.push(t) : () => {};

            addOutput(`==ANTE ${a}==\n`);
            addOutput(`Boss: ${inst.nextBoss(a)}\n`);
            const voucher = inst.nextVoucher(a);
            addOutput(`Voucher: ${voucher}\n`);
            inst.lock(voucher);

            // Unlock next level voucher
            for (let i = 0; i < Immolate.VOUCHERS.size(); i += 2) {
              if (Immolate.VOUCHERS.get(i) === voucher) {
                if (selectedOptions[options.indexOf(Immolate.VOUCHERS.get(i + 1))]) {
                  inst.unlock(Immolate.VOUCHERS.get(i + 1));
                }
              }
            }

            addOutput(`Tags: ${inst.nextTag(a)}, ${inst.nextTag(a)}\n`);
            addOutput("Shop Queue: \n");

            for (let q = 1; q <= cardsPerAnte[a - 1]; q++) {
              addOutput(`${q}) `);
              const item = inst.nextShopItem(a);
              if (item.type === "Joker") {
                if (item.jokerData.stickers.eternal) addOutput("Eternal ");
                if (item.jokerData.stickers.perishable) addOutput("Perishable ");
                if (item.jokerData.stickers.rental) addOutput("Rental ");
                if (item.jokerData.edition !== "No Edition") addOutput(`${item.jokerData.edition} `);
              }
              addOutput(`${item.item}\n`);
              item.delete();
            }

            addOutput("\nPacks: \n");
            const numPacks = a === 1 ? 4 : 6;
            for (let p = 1; p <= numPacks; p++) {
              const pack = inst.nextPack(a);
              addOutput(`${pack} - `);
              const packInfo = Immolate.packInfo(pack);

              if (packInfo.type === "Celestial Pack") {
                const cards = inst.nextCelestialPack(packInfo.size, a);
                for (let c = 0; c < packInfo.size; c++) {
                  addOutput(cards.get(c));
                  if (c + 1 !== packInfo.size) addOutput(", ");
                }
                cards.delete();
              }
              if (packInfo.type === "Arcana Pack") {
                const cards = inst.nextArcanaPack(packInfo.size, a);
                for (let c = 0; c < packInfo.size; c++) {
                  addOutput(cards.get(c));
                  if (c + 1 !== packInfo.size) addOutput(", ");
                }
                cards.delete();
              }
              if (packInfo.type === "Spectral Pack") {
                const cards = inst.nextSpectralPack(packInfo.size, a);
                for (let c = 0; c < packInfo.size; c++) {
                  addOutput(cards.get(c));
                  if (c + 1 !== packInfo.size) addOutput(", ");
                }
                cards.delete();
              }
              if (packInfo.type === "Buffoon Pack") {
                const cards = inst.nextBuffoonPack(packInfo.size, a);
                for (let c = 0; c < packInfo.size; c++) {
                  const joker = cards.get(c);
                  if (joker.stickers.eternal) addOutput("Eternal ");
                  if (joker.stickers.perishable) addOutput("Perishable ");
                  if (joker.stickers.rental) addOutput("Rental ");
                  if (joker.edition !== "No Edition") addOutput(`${joker.edition} `);
                  addOutput(joker.joker);
                  if (c + 1 !== packInfo.size) addOutput(", ");
                  joker.delete();
                }
                cards.delete();
              }
              if (packInfo.type === "Standard Pack") {
                const cards = inst.nextStandardPack(packInfo.size, a);
                for (let c = 0; c < packInfo.size; c++) {
                  const card = cards.get(c);
                  if (card.seal !== "No Seal") addOutput(`${card.seal} `);
                  if (card.edition !== "No Edition") addOutput(`${card.edition} `);
                  if (card.enhancement !== "No Enhancement") addOutput(`${card.enhancement} `);
                  const rank = card.base[2];
                  const rankName = { T: "10", J: "Jack", Q: "Queen", K: "King", A: "Ace" }[rank] || rank;
                  const suitName = { C: "Clubs", S: "Spades", D: "Diamonds", H: "Hearts" }[card.base[0]];
                  addOutput(`${rankName} of ${suitName}`);
                  if (c + 1 !== packInfo.size) addOutput(", ");
                  card.delete();
                }
                cards.delete();
              }
              addOutput("\n");
            }
            addOutput("\n");
          }

          output = outputChunks.join("");
          window.lastRawOutput = output;
          summarizeOutput().finally(() => {
            finalizeAnalysis();
            window.pendingScrollToResults = true;
            window.refreshShopDisplay?.() || document.getElementById("scrollingContainer")?.scrollIntoView({ behavior: "smooth", block: "start" });
          });
        } catch (err) {
          console.error("Analyze failed:", err);
          alert(t("Analyze failed. Check seed/version and try again."));
          finalizeAnalysis();
        } finally {
          if (inst) {
            try {
              inst.delete();
            } catch (_deleteErr) {
              // Ignore cleanup errors
            }
          }
        }
      }, 0);
    }

    // Single ante queue computation
    function computeSingleAnteQueue(targetAnte, cardsLimit) {
      const deck = deckSelect.value;
      const stake = stakeSelect.value;
      const version = parseInt(versionSelect.value);
      const seed = seedInput.value.toUpperCase().replace(/0/g, "O");
      const anteNum = Number(targetAnte);
      const limit = Math.max(0, Number(cardsLimit) || 0);

      if (!Number.isFinite(anteNum) || anteNum < 1 || !limit) return [];
      if (typeof Immolate === "undefined" || !Immolate.Instance) {
        console.error("Immolate wasm not ready for single-ante compute.");
        return [];
      }

      let inst = null;
      const lines = [];

      try {
        inst = createImmolateInstance(seed, deck, stake, version);
        inst.initUnlocks(anteNum, false);

        for (let q = 1; q <= limit; q++) {
          const item = inst.nextShopItem(anteNum);
          try {
            let line = `${q}) `;
            if (item.type === "Joker" && item.jokerData) {
              if (item.jokerData.stickers.eternal) line += "Eternal ";
              if (item.jokerData.stickers.perishable) line += "Perishable ";
              if (item.jokerData.stickers.rental) line += "Rental ";
              if (item.jokerData.edition === "Negative") line += "‚ÄºÔ∏è ";
              line += item.item;
            } else {
              line += item.item;
            }
            lines.push(line);
          } finally {
            item.delete();
          }
        }
      } finally {
        if (inst) {
          try {
            inst.delete();
          } catch (_err) {
            // Ignore cleanup errors.
          }
        }
      }
      return lines;
    }

    window.computeSingleAnteQueue = computeSingleAnteQueue;

    // URL parameter handling
    window.addEventListener("DOMContentLoaded", () => {
      const urlParams = new URLSearchParams(window.location.search);

      // Decode unlocks
      const urlUnlocks = urlParams.get("unlocks");
      if (urlUnlocks) {
        const binaryString = atob(urlUnlocks).split("").map((c) => c.charCodeAt(0).toString(2).padStart(8, "0")).join("");
        const paddingLength = binaryString.length % 8;
        const unpadded = paddingLength > 0 ? binaryString.slice(0, -paddingLength) : binaryString;
        selectedOptions = unpadded.split("").map((b) => b === "1");
      }

      // Apply URL parameters
      const urlAnte = urlParams.get("ante");
      const urlCardsPerAnte = urlParams.get("cardsPerAnte");
      const urlDeck = urlParams.get("deck");
      const urlStake = urlParams.get("stake");
      const urlSeed = urlParams.get("seed");
      const urlVersion = urlParams.get("version");
      const urlOmitBeforeAnte9 = urlParams.get("omitBeforeAnte9");

      if (urlAnte) {
        anteInput.value = clampAnteValue(urlAnte);
        cardsPerAnteInput.value = urlCardsPerAnte || "300";
      }
      if (urlCardsPerAnte) cardsPerAnteInput.value = urlCardsPerAnte;
      if (urlDeck) deckSelect.value = urlDeck;
      if (urlStake) stakeSelect.value = urlStake;
      if (urlVersion) versionSelect.value = urlVersion;
      if (urlOmitBeforeAnte9 !== null) omitBeforeAnte9Checkbox.checked = urlOmitBeforeAnte9 !== "false" && urlOmitBeforeAnte9 !== "0";

      if (urlSeed) {
        seedInput.value = filterSeed(urlSeed);
        window.instantAnalysis = true;
      }

      // Input validation
      seedInput.addEventListener("input", () => (seedInput.value = filterSeed(seedInput.value)));
      anteInput.addEventListener("input", () => (anteInput.value = clampAnteValue(anteInput.value)));
      cardsPerAnteInput.addEventListener("input", () => (cardsPerAnteInput.value = Math.min(Math.max(Number(cardsPerAnteInput.value), 0), 999)));

      function filterSeed(seed) {
        return seed.replace(/[^A-Za-z0-9]/g, "").toUpperCase().replace(/0/g, "O").slice(0, 8);
      }

      // Initial render
      applyUiLocalization();
      renderSummaryList();
      applySummaryEmojiFilter();
    });
  </script>
</html>
